import com.rameses.annotations.*;
import com.rameses.services.extended.*;
import com.rameses.rules.common.*;
import java.rmi.server.UID;
import java.text.SimpleDateFormat;

class NewLoanProductTypeService extends ActiveCrudListService {

	@Env
	def env;

	@ActiveDB( dynamic=true )
	def db;

	@ActiveDB("loan_producttype")
	def em;

	@ActiveDB('datatxnlog') 
	def txnlog;

	@ActiveDB("loan_producttype_attribute")
	def producttype_attribute;

	@ActiveDB("postingheader")
	def postingheader;

	@ActiveDB("ils_fact")
	def ils_fact;

	@ActiveDB("loanapp")
	def loanapp;

	@ActiveDB("loan_ledger")
	def loan_ledger;

	@ActiveDB("loan_ledger_payment")
	def ledger_payment;

	@Resource("RuleService")
	def ruleSvc;

	@Service("DateService")
	def dateSvc;
	
	@Service("NumberService")
	def numSvc;

	@Service
	def selfSvc;

	/*
	private final def POSTING_RULESET = [
		[idx: 0, name: "postprepaid", incrementDays: false, addToPostingList: true], 
		[idx: 1, name: "postperitem", incrementDays: true, addToPostingList: true],
		[idx: 2, name: "postonlastitem"]
	];
	private final def POSTING_GROUP = [
		[idx: 0, name: "PREPAID", incrementDays: false],
		[idx: 1, name: "NORMAL", incrementDays: true]
	]
	*/
	//private final def POSTING_GROUP = ["PREPAID", "NORMAL"];
	private final def POSTING_GROUP = [
		[idx: 0, name: "PREPAID", addToPostingList: true],
		[idx: 1, name: "NORMAL", allowIncrementDays: true, addToPostingList: true],
		[idx: 2, name: "ADVANCE", allowAdvancePosting: true, addToPostingList: true],
		[idx: 3, name: "PASTDUE", isPastDue: true, addToPostingList: true],
		[idx: 4, name: "LAST", getLastItem: true]
	];
	private final def POSTING_RULESET = [
		[idx: 0, name: "postperitem", incrementDays: true, allowPosting: true],
		[idx: 1, name: "postonlastitem", getLastItem: true]
	];
	//private final def POSTING_RULESET = ["postperitem", "postonlastitem"];
	private final def POSTING_RULEGROUP = [
		[idx: 0, name: "before"], 
		[idx: 1, name: "during"], 
		[idx: 2, name: "after"]
	];

	/*
	private def DEFAULT_LOAN_VARLIST = ["AMOUNT", "BALANCE", "TOTAL_PAYMENT", "TOTAL_DUE"]
	private def DEFAULT_POSTING_VARLIST = [
		[name: "DATE_PAID", datatype: "date"],
		[name: "REMARKS", datatype: "string",],
		[name: "REFNO", datatype: "string"],
	]
	*/

	@ProxyMethod
	public def getColumns( params ) {
		def cols = [];

		if (!params.state) cols << [name: "txnstate", caption: "Status"];

		cols << [name: "code", caption: "Code"];
		cols << [name: "title", caption: "Title"];
		cols << [name: "paymentschedule", caption: "Payment Schedule"];

		return cols;
	}

	void beforeList( params ) {
		params.searchtext = (params.searchtext? params.searchtext : "") + "%";
		if (params.state) {
			params._listMethod = "getListByState";
		}
	}

	def getUser() {
		return [objid: env.USERID, name: env.NAME];
	}

	@ProxyMethod
	public def createData( data ) {
		data.dtcreated = dateSvc.serverDate;
		data.author = getUser();
		if (!data.txnstate) data.txnstate = "DRAFT";

		return saveData(data, "create");
	}

	@ProxyMethod
	public def updateData( data ) {
		return saveData(data, "update");
	}

	def saveData( data, mode ) {

		def info;
		def _addedgenattr, _addedloanattr;
		def _removedgenattr, _removedloanattr;
		def _genattr, _loanattr;
		def loanfields;

		if (data.generalinfo) {
			info = data.generalinfo;
			_addedgenattr = info._addedattr? info.remove("_addedattr") : [];
			_removedgenattr = info._removedattr? info.remove("_removedattr") : [];
			_genattr = info.attributes? info.remove("attributes") : [];
		}

		if (data.loaninfo) {
			info = data.loaninfo;
			_addedloanattr = info._addedattr? info.remove("_addedattr") : [];
			_removedloanattr = info._removedattr? info.remove("_removedattr") : [];
			_loanattr = info.attributes? info.remove("attributes") : [];

			loanfields = info?.fields? info.remove("fields") : [];
		}

		if (mode == 'create') {
			em.create( data );
		} else if (mode == 'update') {
			em.update( data );
		}
			
		saveAttributes(data, _genattr, _addedgenattr, _removedgenattr, "GENERAL");
		saveAttributes(data, _loanattr, _addedloanattr, _removedloanattr, "LOAN");
		saveFields(data, loanfields, "LOAN");

		return open(data);
	}

	void saveAttributes( data, list, added, removed, category ) {
		removed?.each{ o->
			em.delete(o, "attribute");
		}

		added?.each{ o->
			if (!o.parentid) o.parentid = data.code;
			o.category = category;
			em.create(o, "attribute");
		}

		list?.findAll{ it._updated==true }?.each{ o->
			if (!o.parentid) o.parentid = data.code;
			o.category = category;
			em.update(o, "attribute");
		}
	}

	void saveFields( data, list, category ) {
		em.removeFieldsByCategory([objid: data.code, category: category]);
		list.each{ o->
			if (!o.category) o.category = category;
			em.create(o, "factfield");
		}
	}

	@ProxyMethod
	public def getStates() {
		return [
			[caption: "All"],
			[caption: "DRAFT", state: "DRAFT"],
			[caption: "ACTIVATED", state: "ACTIVATED"],
			[caption: "DEACTIVATED", state: "DEACTIVATED"]
		];
	}

	void afterOpen( data ) {

		def category;
		if (data.generalinfo) {
			category = "GENERAL";
			def list = [];
			def x = em.getAttributesByCategory([code: data.code, category: category]);
			x?.each{ o->
				def i = em.read(o, "attribute");
				if (i) list << i;
			}
			data.generalinfo.attributes = list;
		}

		if (data.loaninfo) {
			category = "LOAN";
			def list = [];
			def x = em.getAttributesByCategory([code: data.code, category: category]);
			x?.each{ o->
				def i = em.read(o, "attribute");
				if (i) list << i;
			}

			data.loaninfo.attributes = list;

			data.loaninfo.fields = em.getFieldsByCategory([objid: data.code, category: category]);
		}

		/*
		data.attributes = [];
		def l = em.getAttributes(data);
		l.each{ o->
			def i = em.read(o, "attribute");
			data.attributes << i;
		}
		*/
	}

	@ProxyMethod
	public def getFactList( params ) {
		if (!params.category) throw new RuntimeException("Please specify category.");

		params.category = params.category.toLowerCase();
		return em.getFactListByCategory(params).collect{ [objid: it.objid, title: it.defaultvarname, varname: it.defaultvarname] } 
	}

	@ProxyMethod
	public def getFieldList( params ) {
		if (!params.factid) throw new RuntimeException("Please specify factid.");
		//if (!params.category) throw new RuntimeException("Please specify category.");
		//return [];
		return em.getFieldListByFactid( params ).collect{ [objid: it.objid, name: it.name, title: it.title, handler: it.handler] };
	}

	@ProxyMethod
	public def getPostingRuleGroup() {
		return POSTING_RULEGROUP;
	}

	@ProxyMethod
	public def getPostingRuleSet() {
		//def list = POSTING_RULESET.sort{ it.idx }.collect{ it.name }
		//return list;
		return POSTING_RULESET;
	}

	@ProxyMethod
	public def getPostingGroup() {
		//def list = POSTING_GROUP.sort{ it.idx }.collect{ it.name }
		//return list;
		return POSTING_GROUP;
	}

	@ProxyMethod
	public def getDefaultPostingHeader() {
		def list = [];

		postingheader.getListByCategory([searchtext: "%", category: "PRODUCTTYPE"]).each{ o->
			def item = list.find{ it.objid == o.objid }
			if (!item) list << o;
		}

		list.sort{ it.seqno }
		list.eachWithIndex{ o, idx-> 
			o.index = idx;
			o.seqno++;
			o.isfirst = false;
			o.islast = false;
		}

		if (list.size() > 0) {
			list[0].isfirst = true;
			list[list.size() - 1].islast = true;
		}

		return list;
		/*
		def xlist = posting_header.getList([searchtext: '%']);
		
		def list = [], item;
		xlist?.each{ o->
			item = list?.find{ it.code == o.code }
			if (!item) list << o;
		}

		list?.sort{ it.sequence }
		list?.eachWithIndex{ o, idx->
			o.index = idx;
			o.sequence = (idx + 1);
			o.isfirst = false;
			o.islast = false;
		}

		if (list.size() > 0) {
			list.sort{ it.sequence }
			list[0].isfirst = true;
			list[list.size() - 1].islast = true;
		}

		return list;
		*/
	}

	@ProxyMethod
	public def getDefaultGeneralInfoAttributes() {
		def list = getDefaultAttributes([category: 'GENERAL']);
		list.each{ o->
			def val = o.attribute?.defaultvalue;
			o.value = val;
			o.attribute?.value = val;
			o.usedefault = 1;
		}
		return list;
	}

	@ProxyMethod
	public def getDefaultLoanInfoAttributes() {
		def list = getDefaultAttributes([category: 'LOAN']);
		list.each{ o->
			o.handler = o.attribute.type;
			o.computeduringapplication = 1;
			o.computeduringposting = 0;
			o.computeuponmaturity = 0;
		}
		return list;
	}

	def getDefaultAttributes( params ) {
		if (!params.category) throw new RuntimeException("Please specify category.");

		def list = [];
		def x = producttype_attribute.getDefaultAttributesByCategory(params);
		x?.eachWithIndex{ o, idx->
			def i = producttype_attribute.read(o);
			if (i) {
				//i.value = i.defaultvalue;
				def d = [
					objid		: 'LATTR' + new UID(),
					attributeid	: i.code,
					attribute 	: i,
					index 		: idx
				]
				list << d;
			}
		}

		return list;
	}

	@ProxyMethod
	public def getLoanInfoVarlist() {
		def list = [];
		/*
		DEFAULT_LOAN_VARLIST.eachWithIndex{ itm, idx->
			def item = [
				caption 	: itm,
				title 		: itm,
				signature 	: itm,
				handler 	: "decimal",
				description : "(decimal)"
			];
			list << item
		}
		*/
		return list;
	}

	@ProxyMethod
	public def getPostingInfoVarList() {
		def list = [];
		/*
		DEFAULT_POSTING_VARLIST.eachWithIndex{ itm, idx-> 

		}
		*/
		return list;
	}


	@ProxyMethod
	public def getFields( params ) {	
		//def list = postingheader.getFields([objid: params.objid]);
		if (!params.category) params.category = 'producttype';
		params.category = params.category.toLowerCase();

		def list = [];

		/*
		ils_fact.getFactsByCategory( params )?.each{ f->
			ils_fact.getFields( f )?.each{ 
				//println 'fields ' + it;
				def item = [
					factid 	: f.objid, 
					fieldid : it.objid, 
					name 	: f.defaultvarname + "_" + it.name, 
					handler : it.handler
				]; 
				item.title = item.name;
				list << item;
			};
		};
		*/

		if (params.group) {
			def idx = params.index;
			if (!idx) {
	            def mlist = params.sequence?.findAll{ it.group==params.group }
	            idx = mlist?.size();
			}
			if (!idx) idx = 0;

			def xlist = params.sequence?.findAll{ it.group==params.group && it.index < idx && it.varname != null }
		
			def plist = ["total", "paid"];
			xlist?.each{ o->
				def item = [
					caption 	: o.varname,
					title 		: o.varname,
					signature 	: o.name,
					handler 	: o.datatype,
					description : o.datatype
				];
				if (o.datatype == 'decimal') {
					plist.each{ p->
						def xitem = [:];
						xitem.putAll( item );

						xitem.caption = p + '_' + o.varname + ' (per item)';
						xitem.title = p + '_' + o.varname + ' (per item)';
						xitem.signature = p + '_' + o.name + "f";
						list << xitem;
					}
				} else {
					list << item;
				}
	        }
		}

		return list;
	}

	@ProxyMethod
	public def activate( params ) {
		def data = changeState(params, "ACTIVATED");
		return open(data);
	}

	@ProxyMethod
	public def deactivate( params ) {
		def data = changeState(params, "DEACTIVATED");
		return open(data);
	}

	def changeState( params, state ) {
		def data = em.read(params);
		if (!data) throw new RuntimeException("Product type record does not exist or has already been deleted.");

		if (data.txnstate == state) {
			throw new RuntimeException("Product type record has already been " + state + ".");
		}

		data.txnstate = state;
		em.update(data);

		def action, remarks;

		switch (data.txnstate) {
			case 'ACTIVATED':
				action = "Activate";
				remarks = "Product type activated";
				break;
			case 'DEACTIVATED':
				action = "Deactivate";
				remarks = "Product type deactivated";
				break;
		}

		if (action && remarks) {

			def loginfo = [
				objid 	: 'TLOG' + new UID(), 
				txndate : dateSvc.serverDate, 
				txnid   : data.code, 
				user    : [objid: env.USERID, username: env.USER], 
				action	: action, 
				remarks : remarks 
			]; 
			txnlog.create( loginfo ); 
		}

		return open(data);
	}

	@ProxyMethod
	public def executeProductTypeRulesForLoanApplication( producttype, params, type, prmdata ) {
		def data = open(producttype);

		def bindings = [:];
		def result = [:];

		data.generalinfo?.attributes.each{ o->
			bindings[o.attribute.varname] = o.value;
		}

		def info = data.loaninfo;
		if (info) {
			info.fields.each{ o->
				def factfield = ils_fact.read([objid: o.field.objid], "factfield");
				if (factfield && factfield.source=='database') {
					if (type == 'database') {

						def schema  = db.lookup("main", factfield.schemaname);

						def xprm = [:];
						xprm[factfield.primarykey] = params[factfield.paramkey];

						def f = schema.read(xprm);
						if (factfield.subschemaname) {
							f = schema.read(xprm, factfield.subschemaname);
						}
						//println 'schema ' + factfield.schemaname + ' subschema ' + factfield.subschemaname + ' f ' + f;
						bindings[o.title] = f? f[factfield.fieldname] : null;	
					} else {
						def schema = prmdata[factfield.schemaname];
						bindings[o.title] = schema? schema[factfield.fieldname] : null;
					}
				}
			}

			//info.attributes[0].each{ println it }

			def list = info.attributes?.findAll{ it.computeduringapplication==1 }
			list.sort{ it.index }
			list.each{ o->
				//println 'bindings';
				//bindings?.each{ println it };
				def res = executeRule(bindings, o);
				bindings[o.attribute.varname] = res[o.attribute.fieldname];
				//println '';
			}

			list.each{
				result[it.attribute.fieldname] = bindings[it.attribute.varname]
			}
		}

		return result; 
	}

	@ProxyMethod
	public def xexecuteProductTypeRulesForLoanApplication( producttype, params ) {
		def data = open(producttype);

		def bindings = [:];
		def result = [:];

		data.generalinfo?.attributes.each{ o->
			bindings[o.attribute.varname] = o.value;
		}

		def info = data.loaninfo;
		if (info) {
			info.fields.each{ o->
				def factfield = ils_fact.read([objid: o.field.objid], "factfield");
				if (factfield && factfield.source=='database') {					
					def schema  = db.lookup("main", factfield.schemaname);

					def xprm = [:];
					xprm[factfield.primarykey] = params[factfield.paramkey];

					def f = schema.read(xprm);
					if (factfield.subschemaname) {
						f = schema.read(xprm, factfield.subschemaname);
					}
					bindings[o.title] = f[factfield.fieldname];
				}
			}

			//info.attributes[0].each{ println it }

			def list = info.attributes?.findAll{ it.computeduringapplication==1 }
			list.sort{ it.index }
			list.each{ o->
				def res = executeRule(bindings, o);
				bindings[o.attribute.varname] = res[o.attribute.fieldname];
			}

			list.each{
				result[it.attribute.fieldname] = bindings[it.attribute.varname]
			}
		}

		return result;
	}

	@ProxyMethod
	public def xxtestExpression( params ) {

		def ref = [executingBase: true, executingRuleset: false];
		def base = [
			index 	: 0,
			sequence: [
				[name: "base1"],
				[name: "base2"],
				[name: "base3"]
			]
		];
		def ruleset = [
			index 	: 0,
			sequence: [
				[name: "sequence1"],
				[name: "sequence2"],
				[name: "sequence3"],
				[name: "sequence4"]
			]
		];


		def req = new RuleRequest("testing_rules");
		req.addFact( "testing_rules", "References", ref );
		req.addFact( "testing_rules", "Base", base );
		req.addFact( "testing_rules", "Ruleset", ruleset );

		try {

			ruleSvc.execute(req);
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		}

	}

	@ProxyMethod
	public def xtestExpression( params ) {
		def data = open( params );


	}

	@ProxyMethod
	public def testExpression( params ) {
		def data = open( params );

		def bindings = [:];
		def bindings2 = [:];
		def loanbindings = [:];

		def xparams = [
			appid		: "LOAN7385099b:15c0faf1736:-7ff6",
			ledgerid	: "LEDGER-7d4c2fc0:145c6219f8c:-77c6",
			payments 	: [
				[paymentid: "LLP-4da142a:145c7c7e749:1632"],
				//[paymentid: "LLP70b6b5f0:145ebcbaa08:-d71"],
				//[paymentid: "LLP70b6b5f0:145ebcbaa08:-d6f"]
			]
		];


		xparams.payments?.each{
			def i = loan_ledger.read([objid: it.paymentid], "payment");
			if (i) {
				i.totalpaid = [:];
				i.lacking = [:];
				i.current = [:];
				loan_ledger.update(i, "payment");
			}
		}

		def appc = loanapp.read([objid: xparams.appid], "loanapp_capture");

		def appextinfo = loanapp.read( [objid: xparams.appid], "extinfo" );
		if (appextinfo) {
			appextinfo.loaninfo = [:];
			loanapp.update( appextinfo, "extinfo" );
		}

		def ledger = loan_ledger.read([objid: xparams.ledgerid]);
		if (ledger) {
			def dt = incrementDate( appc?.dtreleased, 1, data.paymentschedule );
			if (dt) {
				ledger.dtcurrentschedule = dt;
				loan_ledger.update( ledger );
			}
		}

		//LLP-4da142a:145c7c7e749:1632 2000-03-17
		//LLP70b6b5f0:145ebcbaa08:-d71 2000-03-21
		//LLP70b6b5f0:145ebcbaa08:-d6f 2000-03-23

		//do not remove 
		def app = [:];
		def info = data.loaninfo;
		if (info) {

			data.generalinfo?.attributes.each{ o->
				//bindings[o.attribute.varname] = o.value;
				bindings[o.attribute.varname] = [key: o.attribute.fieldname, value: o.value];
				//["GENINFO_" + o.attribute.varname] = o.value;
				bindings["GENINFO_" + o.attribute.varname] = [key: o.attribute.fieldname, value: o.value];
				//loanbindings[o.attribute.varname] = o.value;
				loanbindings[o.attribute.varname] = [key: o.attribute.fieldname, value: o.value];
			}


			info.fields.each{ o->
				def factfield = ils_fact.read([objid: o.field.objid], "factfield");
				if (factfield && xparams[factfield.paramkey] && factfield.source=='database') {					
					def schema  = db.lookup("main", factfield.schemaname);
			
					def xprm = [:];
					xprm[factfield.primarykey] = xparams[factfield.paramkey];

					def f = schema.read( xprm );
					if (factfield.subschemaname) {
						f = schema.read(xprm, factfield.subschemaname);
					}
					//println 'o->' + o;
					def val = f[factfield.fieldname];
					//[key: o.attribute.fieldname, value: val];
					bindings[o.title] = [key: o.field.name, value: val];
				}
			}

			//info.attributes[0].each{ println it }

			app = loanapp.read([objid: xparams.appid]);
			def list = info.attributes?.findAll{ it.computeduringapplication==1 }
			list.sort{ it.index }
			list.each{ o->
				def res = executeApplicationRule(bindings, o);
				//println 'result-> ' + res;
				def val = res[o.attribute.fieldname];
				//bindings[o.attribute.varname] = res[o.attribute.fieldname];
				bindings[o.attribute.varname] = [key: o.attribute.fieldname, value: val];

				if (o.updatedb == 1 && o.db?.dbname == 'loanapp') {
					app[o.db.fieldname] = val;
				}
			}

			//def app = [:];
			//list.each{
				//println it.attribute.fieldname + '-> ' + bindings[it.attribute.varname];
			//	app[it.attribute.fieldname] = bindings[it.attribute.varname]
			//}
			//println 'bindings';
			//bindings?.each{ println it }

			/*
			//bindings = [:];
			info.attributes?.each{ 
				//bindings[it.attribute.varname] = null;
				if (app[it.attribute.fieldname]) {
					//bindings[it.attribute.varname] = app[it.attribute.fieldname];
					bindings2["LOANINFO_" + it.attribute.varname] = app[it.attribute.fieldname];
					loanbindings[it.attribute.varname] = app[it.attribute.fieldname];

					if (it.updatedb==1) {
						def prm = [objid: xparams.ledgerid];
						prm[it.db.fieldname] = app[it.attribute.fieldname];
						loan_ledger.update( prm );
					}
				}
				
			}
			*/
		}

		//println 'bindings';
		//bindings?.each{ println it }
		//return;

		//println 'loanbindings';
		//loanbindings?.each{ println it }
		//println '';
		//return;

		//println 'bindings';
		//bindings.each{ println it }

		//println 'binding2';
		//bindings?.each{ println it }

		//println 'application';
		//app.each{ println it }

		/*
		println 'bindings';
		bindings?.each{ println it };
		println '\n';
		println 'loan bindings';
		loanbindings?.each{ println it }
		println '';
		*/

		//println 'loanbindings';
		//loanbindings?.each{ println it }
		//println ''

		info = data.postinginfo;
		def appinfo = data.loaninfo;
		def geninfo = data.generalinfo;
		if (info) {
			appinfo.loanbindings = loanbindings;
			//println 'loan bindings';
			//loanbindings?.each{ println it }
			//println '';

			def posting = [];
			def prevpaymentid;
			xparams.payments?.each{ p->

				def xprm = [appid: xparams.appid, ledgerid: xparams.ledgerid, paymentid: p.paymentid, prevpaymentid: prevpaymentid]; 
				def bc = copyMap( bindings2 );
				def result = executePostingRule( data, bc, geninfo, appinfo, info, xprm );
				//if (p.paymentid=="LLP70b6b5f0:145ebcbaa08:-d6f" && result.list) {
					posting.addAll( result.list );
				//}
				prevpaymentid = p.paymentid;
				/*
				info.postingsequence.each{
					//println 'ps ' + it;
					//println 'fields ' + it.fields;
					//println 'expr ' + it.postingexpr;
					//def fields = postingheader.getFields([objid: it.objid]);
					//if (fields) {
					//	println 'fields ' + fields;
					//}
					//println '';
				}
				*/
			}

			println 'posting';
			posting?.each{ println it }

		}

	}



	def executeApplicationRule( bindings, item ) {

		//println 'bindings';
		//bindings?.each{ println it }
		//println '';

		def result = [:];

		def ref = [
			isDecimal	: item?.attribute?.datatype=='decimal'? true : false,
			isDate 		: item?.attribute?.datatype=='date'? true : false
		];
		def req = new RuleRequest("general_rules");
		req.addFact('general_rules', 'References', ref);

		def actions = new RuleAction(); 
		actions.addCommand( "calcAmount", new ils_rules.general.actions.CalcAmount( NS: numSvc, data: result ) );
		actions.addCommand( "calcDate", new ils_rules.general.actions.CalcDate( DS: dateSvc, data: result ) );
		//actions.addCommand( "buildBindings", new ils_rules.general.actions.BuildBindings( data: result ) );

		req.addGlobal("bindings", bindings);
		req.addGlobal("action", actions);
		req.addGlobal("fieldname", item.attribute.fieldname);
		req.addGlobal("expr", item.expr);

		//println 'expr->' + item.expr;

		try {

			ruleSvc.execute( req );
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		}

		//println 'result-> ' + result;

		return result;
	}

	def executePostingRule( data, bindings, geninfo, appinfo, item, params ) {

		/*
		def method = "test";

		try {
			println 'class-> ' + selfSvc.getClass();
			selfSvc.getClass().getInvocationHandler( selfSvc.getClass() ).invoke( selfSvc.getClass(), "deactivate", [] );
			//println 'has method deactivate-> ' + selfSvc.invoke("deactivate", new HashMap());
		} catch (Exception e) {
			e.printStackTrace();
		}
		*/

		/*
		try {
			println 'class1-> ' + this.getClass();
			//println 'has method deactivate2-> ' + this.invoke("deactivate", new HashMap());
		} catch (Exception e) {
			e.printStackTrace();
		}
		*/

		if (!item.advanceposting) item.advanceposting = [:];
		if (item.advanceposting.allow == null) item.advanceposting.allow = false;
		
		def appextinfo = loanapp.read([objid: params.appid], "extinfo");


		//throw new RuntimeException("stop");
		def pyt = loan_ledger.read([objid: params.paymentid], "payment");

		switch (params.paymentid) {
			case "LLP70b6b5f0:145ebcbaa08:-d71":
				if (!params.prevpaymentid) {
					params.prevpaymentid = "LLP-4da142a:145c7c7e749:1632";
				}
				break;
			case "LLP70b6b5f0:145ebcbaa08:-d6f":
				if (!params.prevpaymentid) {
					params.prevpaymentid = "LLP70b6b5f0:145ebcbaa08:-d71";
				}
				break;
		}

		def prevpayment;
		if (params.prevpaymentid) {
			prevpayment = loan_ledger.read([objid: params.prevpaymentid], "payment");
		}
		//println 'prevpayment';
		//println prevpayment;
		//println '';
		//println 'payment';
		//println pyt;
		//println '';
		def ledger = loan_ledger.read( [objid: params.ledgerid] );
		ledger.dtlastpaid = pyt.txndate;

		//println 'current schedule ' + ledger?.dtcurrentschedule + ' payment date->' + pyt.txndate;

		pyt.previous = [
			balance 	: ledger.balance,
			dtschedule 	: ledger.dtcurrentschedule
		];

		//println 'before get total days params->' + params;
		def totaldays = getTotalDays( params );
		//println 'total days ' +  totaldays;

		def postinggroup = [index: 0, sequence: POSTING_GROUP];
		def ruleset = [index: 0, sequence: POSTING_RULESET];
		def rulegroup = [index: 0, sequence: POSTING_RULEGROUP];


		//def postingsequence = [];
		//item.postingsequence.each{ 
		///	println 'fields ' + it.fields;
		//	postingsequence << [objid: it.objid, title: it.title, fields: it.fields];
			//println 'seq ' + it ;
		//}
		//println 'fields-> ' + appinfo?.fields?.size();
		//appinfo?.fields?.each{ println it }
		//throw new RuntimeException("stopping");


		def loanBindings = [:];
		if (appinfo.loanbindings) loanBindings.putAll( appinfo.loanbindings );

		def applist = appinfo?.attributes?.findAll{ it.computebeforeposting==1 && it.attribute.varname != null }
		//println 'before posting->' + applist?.size();
		if (applist) {
			def xbindings = [:]
			xbindings.putAll( copyMap( loanBindings ) );

			def bd = buildBindings( appinfo?.fields, params );
			if (bd) xbindings.putAll( bd );

			applist.sort{ it.index }
			applist.each{ o->

				def res = executeApplicationRule(xbindings, o);
				def val = res[o.attribute.fieldname];
				def varname = o.attribute.varname;
				xbindings[varname] = val;
				loanBindings[varname] = val;
				bindings["LOANINFO_" + varname] = val;
				//println 'varname->' + varname + ' val->' + val;
			}


		}
		//println 'after before posting';

		def isPastDue = getIsPastDue( pyt?.txndate );
		applist = appinfo?.attributes?.findAll{ it.computeduringposting==1 && it.attribute.varname != null }
		
		if (isPastDue) {
			def l = appinfo?.attributes?.findAll{ it.computeuponmaturity==1 && it.attribute.varname != null }
			if (l) applist.addAll( l );
		}

		if (applist) {

			def fields = appinfo.fields;
			if (!fields) fields = [];

			applist.each{ 
				if (!it.fields) it.fields = [];
				it.fields.addAll( fields );
			}
		}

		//println 'loanbindings';
		//loanBindings?.each{ println it }

		//println 'attributes->' + applist?.size();
		//println 'app attributes';
		//applist?.each{ println it }
		//throw new RuntimeException("stopping");
		//println 'seq';
		//postingsequence.each{ println it }
		if (!bindings) bindings = [:];
		def bindingsCopy = [:];
		bindingsCopy.putAll( bindings );
		def result = [:];

		def ref = [
			executingGroup 			: true,
			executingRulegroup		: false,
			executingRuleset 		: false,
			executingAdvancePosting : false,
			allowPosting			: false, 
			allowRepost 			: false,
			buildBindings 			: false, 
			onSupplyValue 			: false, 
			onPostItem 				: false,
			loanAppSupplyOnPosting 	: false,
			isPastDue 				: isPastDue,
			allowAdvancePosting 	: false, //item.advanceposting?.allow,
			dbParams				: params,
			totalDays 				: totaldays
		];

		//println 'is past due->' + ref.isPastDue;
		//println 'allow advance posting->' + ref.allowAdvancePosting;

		//println 'posting sequence';
		//item.postingsequence?.each{ println it }

		def posting = [
			index 					: 0, 
			sequence 				: item.postingsequence, 
			postingItems 			: [], 
			daysCount				: 1, 
			incrementAfterPosting 	: [:], 
			incrementDays 			: false
		];


		//println 'posting sequence';
		posting.sequence?.each{ 
			if (it.header) {
				def h = postingheader.read([objid: it.header.objid]);
				if (h) it.header.fieldstoupdate = h.fieldstoupdate;
			}
		}
		//println '';

		def loan = [
			index 		: 0, 
			attributes 	: applist, 
			bindings 	: loanBindings,
			info 		: [:]
		];

		//loan?.attributes?.each{ println it }

		//println 'attributes->' + loan.attributes?.size();

		if (appextinfo?.loaninfo) {
			loan.info = appextinfo.loaninfo;
		}

		def payment = [
			amount 				: 0.0d, 
			deductableToAmount 	: 0.0d, 
			date 				: pyt?.txndate, 
			current 			: [:], 
			totalPaid 			: [:], 
			total 				: [:], 
			lacking 			: [:],
			balance 			: 0.0d
		];

		def ap = [:];
		if (item.advanceposting) ap = item.advanceposting;

		def advancePosting = [
			amount 		: 0.0d,
			amountExpr 	: ap?.expr,
			datatype 	: ap?.datatype,
			varname 	: ap?.varname,
			fields 		: ap?.fields,
			constraints : ap?.constraints,
			expressions : ap?.expressions,
			allowPost 	: ap?.allow
		]
		//println 'advance posting';
		//advancePosting?.each{ println it }

		//def payment = [amount: 0.0d, deductableToAmount: 0.0d, date: pyt?.txndate, current: [:], totalPaid: [:], total: [:], lacking: []]
		if (pyt?.amount) {
			payment.amount = ((BigDecimal) pyt.amount).toDouble();
			payment.balance = payment.amount;
		}


		if (prevpayment) {
			//println 'prevpayment '+ prevpayment.objid;
			//println 'total paid->' + prevpayment.totalpaid;
			payment.totalPaid = prevpayment.totalpaid;
			payment.lacking = prevpayment.lacking;
			payment.current = prevpayment.current;

			//println 'prevpayment->' + prevpayment;
			//println 'lacking-> ' + payment.lacking;
		}


		/*
		println 'ref';
		ref.each{ println it }
		println '\nposting';
		posting.each{ println it }
		*/

		def req = new RuleRequest( "product_type_rules" );
		req.addFact( "product_type_rules", "References", ref );
		req.addFact( "product_type_rules", "Posting", posting );
		req.addFact( "product_type_rules", "Payment", payment );
		req.addFact( "product_type_rules", "Loan", loan );
		req.addFact( "product_type_rules", "Ruleset", ruleset );
		req.addFact( "product_type_rules", "Rulegroup", rulegroup );
		req.addFact( "product_type_rules", "Group", postinggroup );
		req.addFact( "product_type_rules", "AdvancePosting", advancePosting );

		//println '';
		//println 'posting';
		//posting?.each{ println 'kv-> ' + it }
		//println '';

		/*
		println 'ref';
		ref.each{ println it }
		println '';
		println 'posting';
		posting.each{ println it }
		*/

		//throw new RuntimeException("stop");

		def actions = new RuleAction(); 
		actions.addCommand( "buildBindings", new ils_rules.general.actions.BuildBindings( SERVICE: selfSvc ) );
		actions.addCommand( "buildAppBindings", new ils_rules.general.actions.BuildAppBindings( SERVICE: selfSvc ) );
		actions.addCommand( "validateConstraintExpression", new ils_rules.general.actions.ValidateConstraintExpression( SERVICE: selfSvc ) )
		actions.addCommand( "supplyFieldValue", new ils_rules.general.actions.SupplyFieldValue( NS: numSvc ) );
		actions.addCommand( "postItem", new ils_rules.general.actions.PostItem( NS: numSvc, SERVICE: selfSvc ) );

		def postingItems = [];

		req.addGlobal("action", actions);
		req.addGlobal("bindings", bindings);
		req.addGlobal("bindingsCopy", bindingsCopy);
		req.addGlobal("items", postingItems);

		//println 'payment';
		//payment?.each{ println it }
		def paymentCopy = copyMap( payment );
		req.addGlobal("paymentCopy", paymentCopy);

		def postingCopy = copyMap( posting );
		req.addGlobal("postingCopy", postingCopy);

		def loanCopy = copyMap( loan );
		req.addGlobal("loanCopy", loanCopy);

		//println '';
		//println 'loan';
		//loan?.each{ println it }

		//println 'payment';
		//payment?.each{ println it }
		//println '';

		//println 'references';
		//ref?.each{ println it }
		//println '';

		/*
		println 'attributes';
		if (loan?.attributes) {
			def aaa = loan.attributes[0];
			if (aaa.fields) {
				aaa.fields[0].each{ println it }
			}
		}
		*/
		//loan?.attributes?.each{ println it }
		//return [list: []];

		try {
			ruleSvc.execute( req );
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		}

		/*
		def items = posting.postingItems;

		items.sort{ it.idx };
		if (items) {
			def i = items[items.size() - 1];
			//if (i) {
			//}
		}
		*/


		//println '';
		//println 'totalpaid->' + payment.totalPaid;
		//println 'total->' + payment.total;
		//println 'lacking->' + payment.lacking;
		//println 'current->' + payment.current;
		//println '';

		pyt.totalpaid = payment.totalPaid;
		pyt.lacking = payment.lacking;
		pyt.current = payment.current;


		if (posting.incrementAfterPosting?.dtschedule) {
			def cal = Calendar.getInstance();
			cal.setTime( parseDate(ledger.dtcurrentschedule) );

			cal.add( Calendar.DATE, posting.incrementAfterPosting.dtschedule );
			ledger.dtcurrentschedule = parseDate( new SimpleDateFormat("yyyy-MM-dd").format(cal.getTime()) );
			//edger.dtcurrentschedule = pyt.current?.dtschedule;
		}

		def xxl = loan_ledger.read( [objid: ledger.objid] );
		println 'xxl->' + xxl;

		if (pyt.current?.balance) {
			ledger.balance = pyt.current?.balance;
		}

		//println 'increment after posting-> ' + posting.incrementAfterPosting

		//println 'balance-> ' + ledger.balance;
		//println 'dtcurrentschedule-> ' + ledger.dtcurrentschedule;

		if (postingCopy?.incrementAfterPosting?.dtschedule) {
			ledger.dtcurrentschedule = incrementDate( ledger.dtcurrentschedule, postingCopy.incrementAfterPosting.dtschedule, data.paymentschedule);
		}

		loan_ledger.update(pyt, "payment");
		loan_ledger.update( ledger );

		//println 'loan info1';
		//loan.info?.each{ println it }
		//println '';

		//println 'loan info';
		//loanCopy.info?.each{ println it }
		//println '';
		
		appextinfo.loaninfo = loanCopy.info;
		loanapp.update(appextinfo, "extinfo");

		postingItems?.each{
			if (!it.paymentid) it.paymentid = params.paymentid;
		}

		/*
		println 'payment';
		pyt?.each{ println it }
		println '';
		*/

		/*
		println 'bindings';
		bindings?.each{ println it }
		println '';
		*/

		/*
		println 'payment';
		payment.each{ println it }
		println '';
		*/

		//println 'posting items ';
		//posting.postingItems.each{ println it };
		//println '';

		//println 'posting items->' + postingItems;
		//postingItems?.each{ println it }
		//println '';

		result.list = postingItems;
		//result.list = posting.postingItems;

		//println '';
		//println 'payment';
		//payment?.each{ println it }
		//println '';
		//println 'payment copy';
		//paymentCopy?.each{ println it }
		//println '';
		//println 'lacking->' + payment.lacking;
		//println 'amount->' + payment.amount + ' deductable to amount->' + payment.deductableToAmount;

		//println 'result-> ' + result;


		//throw new RuntimeException("stopping");
		return result;
	}

	def copyMap( src ) {
		def item = [:];
		src?.each{ k, v->
			if (v instanceof Map) {
				//println 'instanceof Map-> ' + k + ' ' + v;
				item[k] = copyMap( v );
			} else {
				item[k] = v;
			}
		}

		return item;
	}

	def incrementDate( date, addToDate, type ) {
		if (!date) return;
		Calendar cal = Calendar.getInstance();
		cal.setTime( date );
		
		switch (type) {
			case 'DAILY'	: cal.add(Calendar.DATE, addToDate); break;
		}

		date = parseDate("yyyy-MM-dd", cal.getTime());
		return date;
	}

	def getIsPastDue( date ) {
		def flag = false;

		if (date != null) {
			def dt = parseDate( date );
			def dt2 = parseDate( dateSvc.serverDate.toString().split(' ')[0] )

			if (dt > dt2) {
				flag = true;
			}
		}

		return flag;
	}

	@ProxyMethod
	public def getTotalDays( params ) {

		def ledger = loan_ledger.read([objid: params.ledgerid]);
		def payment = loan_ledger.read([objid: params.paymentid], "payment");

		def ref = [
			isDecimal: false, 
			isDate: false, 
			isComputeTotalDays: true
		];
		def totalDaysRef = [
			currentSchedule: ledger?.dtcurrentschedule, 
			paymentDate: payment?.txndate, 
			totalDays: 0
		];
		/*
		if (params.incrementdtschedule) {

		}
		*/
		//println 'total days ref ' + totalDaysRef;

		def req = new RuleRequest( "general_rules" );
		req.addFact( "general_rules", "References", ref );
		req.addFact( "general_rules", "ComputeTotalDaysReference", totalDaysRef );

		Map result = [:];

		req.addGlobal("resultMap", result);

		try {

			ruleSvc.execute(req);
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		}

		//println 'total days ' + totalDaysRef.totalDays;
		//println 'resutl ' + result;
		//if (!result.totaldays) result.totaldays = 1;
		if (result.totaldays == null) result.totaldays = 0;
		return result.totaldays;
		//throw new RuntimeException("stop total days");
	}

	@ProxyMethod
	public def getTotalPayment( params ) {
		//println 'paymentid->' + params.paymentid;
		def payment = loan_ledger.read([objid: params.paymentid], "payment");


		def xlist = ledger_payment.getPaymentsByParentidAndTxndate([parentid: payment?.parentid, txndate: payment.txndate]);
		xlist.sort{ it.refno }

		def amt = 0;

		for (int i=0; i<xlist.size(); i++) {
			def pyt = xlist[i];
			amt += pyt.amount;
			if (pyt.objid == payment.objid) {
				break;
			}
		}

		//println 'total payment->' + amt;


		return amt;
	} 

	@ProxyMethod
	public def getTotal( params, type ) {
		def amt = 0;
		/*
		swtich (type) {
			case 'interest':
				if (params.total['interest']) {
					amt = params.t
				}
				break;
			case 'penalty':

				break;
		}
		*/
		//println 'total->' + params.total;
		if (params.total[type]) {
			amt = params.total[type];
		}

		return amt;
	}

	@ProxyMethod
	public def getRemarks( params ) {
		def remarks = '';

		def payment = loan_ledger.read([objid: params.paymentid], "payment");

		def xlist = ledger_payment.getPaymentsByParentidAndTxndate([parentid: payment?.parentid, txndate: payment.txndate]);

		if (xlist?.size() > 0) {
			xlist.sort{ it.refno }

			def amt = 0;
			def hasTotalPayment = false;

			for (int i=0; i<xlist.size(); i++) {
				def pyt = xlist[i];
				amt += pyt.amount;
				if (pyt.objid == payment.objid) {
					if (i > 0) hasTotalPayment = true;
					break;
				}
			}

			if (hasTotalPayment) {
				remarks += amt + ' Total Payment \n';
			}
		}

		if (params.lacking) {
			params.lacking.each{ k, v->
				if (v > 0) {
					remarks += 'Lacking ' + k + ' ' + v + ' \n';
				}
			}
		}

		//println 'params ' + params;

		return remarks;
	}

	@ProxyMethod
	public def buildAppBindings() {

	}


	@ProxyMethod
	public def buildBindings( fields, params ) { 
		println 'build bindings';
		//println 'fields';

		println 'params';
		params.each{ println it }

		def bindings = [:];
		fields.each{ f->
			def field = ils_fact.read([objid: f.field.objid], "factfield");
			if (field) {
				//println 'f->' + f;
				//println 'field->' + field;
				if (field?.source=="database") {	
					def schema  = db.lookup("main", field.schemaname);

					def prm = [:];
					prm[field.primarykey] = params[field.paramkey];

					def ff = schema.read(prm);
					if (field.subschemaname) {
						ff = schema.read(prm, field.subschemaname);
					}
					bindings[f.title] = ff[field.fieldname];
				} else if(field?.source=="user") {

					//println 'field name ' + field?.name;
					switch (field.name) {
						case 'totaldays':
							def val;
							if (params.totaldays) {
								val = params.totaldays;
							} else {
								params.incrementafterposting?.each{ k, v->
									params["increment" + k] = v;
								}
								val = getTotalDays( params );	
							}
							//println 'totaldays-> ' + val;
							bindings[f.title] = val;
							break;
						case 'totalpayment':
							def val = getTotalPayment( params );
							//println 'totalpayment-> ' + val;
							bindings[f.title] = val;
							break;
						case 'totalinterest':
							//println 'title->' + f.title + ' total->' + params.total;
							bindings[f.title] = getTotal( params, "interest" );
							break;
						case 'totalpenalty':
							bindings[f.title] = getTotal( params, "penalty" );
							break;
						case 'remarks':
							bindings[f.title] = getRemarks( params );
							break;
						case 'balance':
							bindings[f.title] = params.PAYMENT.balance;
							break;
					}

					//println 'field ' + field;
				}
			}
			//f.each{ println it } 
			//println ''
		}

		//println 'bindings';
		//bindings.each{ println it }
		return bindings;
	}

	@ProxyMethod
	public def buildConstraintExpressionList( params ) {
		def bindings = [:]
		if (params.bindings) bindings = copyMap( params.bindings );

		def item = [:];
		if (params.postingitem) item = copyMap( params.postingitem );

		def exprList = [];
		params.constraints?.each{ c->
			if (c.field?.signature) {
				def f = c.field?.signature;
				def val;
				if (bindings[ f ]) {
					val = bindings[ f ];
				} else {
					if (item[ f ]) {
						val = item[ f ];
					}
				}
				if (c.varname) {
					bindings[ c.varname ] = val;
				} else {
					if (!bindings[ f ]) {
						bindings[ f ] = val;
					}
				}

				if (c.operator?.symbol) {
					def expr = f;
					if (c.varname) {
						expr = c.varname;
					} 

					expr += " " + c.operator.symbol;
					if (c.usevar == 1) {
						
						//def val2 = 0;
						//if (bindings[ c.var?.name ]) {
						//	val2 = bindings[ c.var?.name ];
						//}
						//expr += " " + val2;

						if (c.var?.name) {
							expr += " " + c.var.name;
						}
					} else {
						def val2;
						switch (c.field?.handler) {
							case 'decimal':
								if (!c.decimalvalue) c.decimalvalue = 0;
								val2 = c.decimalvalue;
								break;
							case 'date':
								if (!c.datevalue) c.datevalue = "";
								val2 = c.datevalue;
								break;
							case 'integer':
								if (!c.intvalue) c.intvalue = 0;
								val2 = c.intvalue;
								break;
						}

						expr += " " + val2;
					}
					exprList << [expr: "return (" + expr + ");", bindings: bindings];
				}
			}



			/*
			if (c.field?.handler) {

				def f = c.field?.signature;
				def val = 0;
				if (bindings[ f ]) {
					val = bindings[ f ];
				} else {
					if (item[ f ]) {
						val = item[ f ];
					}
				}
				if (c.varname) {
					bindings[ c.varname ] = val;
				}

				if (c.operator?.symbol) {
					def expr = val + " " + c.operator.symbol;
					if (c.usevar == 1) {
						def val2 = 0;
						if (bindings[ c.var?.name ]) {
							val2 = bindings[ c.var?.name ];
						}
						expr += " " + val2;
					} else {
						if (!c.decimalvalue) c.decimalvalue = 0;
						expr += " " + c.decimalvalue;
					}
					exprList << "return (" + expr + ");";
				}
			}
			*/

			//println 'cons->' + c;
			/*
			switch (c.field?.handler) {
				case 'decimal':
					def f = c.field?.signature;
					def val = 0;
					if (bindings[ f ]) {
						val = bindings[ f ];
					} else {
						if (item[ f ]) {
							val = item[ f ];
						}
					}
					if (c.varname) {
						bindings[ c.varname ] = val;
					} else {
						if (!bindings[ f ]) {
							bindings[ f ] = val;
						}
					}

					if (c.operator?.symbol) {
						def expr = val;
						if (c.varname) {
							expr = c.varname;
						} 

						expr += " " + c.operator.symbol;
						if (c.usevar == 1) {
							
							//def val2 = 0;
							//if (bindings[ c.var?.name ]) {
							//	val2 = bindings[ c.var?.name ];
							//}
							//expr += " " + val2;

							if (c.var?.name) {
								expr += " " + c.var.name;
							}
						} else {
							if (!c.decimalvalue) c.decimalvalue = 0;
							expr += " " + c.decimalvalue;
						}
						exprList << [expr: "return (" + expr + ");", bindings: bindings];
					}
					break;
				case 'date':
					def f = c.field?.signature;
					def val = '';
					if (bindings[ f ]) {
						val = bindings[ f ];
					} else {
						if (item[ f ]) {
							val = item[ f ];
						}
					}
					if (c.varname) {
						bindings[ c.varname ] = val;
					} else {
						if (!bindings[ f ]) {
							bindings[ f ] = val;
						}
					}

					if (c.operator?.symbol) {
						def expr = val.toString();
						if (c.varname) {
							expr = c.varname;
						}
						expr += " " + c.operator.symbol;
						//def expr = val.toString() + " " + c.operator.symbol;
						if (c.usevar == 1) {
							if (c.var?.name) {
								expr += " " + c.var.name;
							}

							//def val2 = 0;
							//if (bindings[ c.var?.name ]) {
							//	val2 = bindings[ c.var?.name ];
							//}
							//expr += " " + val2;

						} else {
							if (!c.datevalue) c.datevalue = "";
							expr += " " + c.datevalue;
						}
						exprList << [expr: "return (" + expr + ");", bindings: bindings];
					}
					break;
			}
			*/

		}

		//println 'expr list';
		//exprList?.each{ println it }

		return exprList;
	}

	@ProxyMethod
	public def updateDB( item, values, incrementafterposting, params ) {

		def x = item.updatedb;

		def schema  = db.lookup("main", x.schemaname);

		def prm = [:];
		prm[x.primarykey] = params[x.paramkey];

		def ff = schema.read( prm );
		if (x.subschemaname) {
			ff = schema.read( prm, x.subschemaname );
		}
		def val = ff[ x.fieldname ];

		switch (item?.datatype) {
			case 'date':
				if (incrementafterposting[ item?.header?.name ]) {
					def cal = Calendar.getInstance();
					cal.add( Calendar.DATE, incrementafterposting[ item?.header?.name ]);
					val = parseDate( "yyyy-MM-dd", cal.getTime() );
				}
				break;
		}

		prm[ x.fieldname ] = val;
		if (x.subschemaname) {
			schema.update( prm, x.subschemaname );
		} else {
			schema.update( prm );
		}

		//bindings[f.title] = ff[field.fieldname];
		//println 'updatedb method';
		//println 'val->' + val;
		/*
		println 'item';
		item?.each{ println it }
		println '';
		println 'values';
		values?.each{ println it }
		println '';
		println 'increment after posting';
		incrementafterposting?.each{ println it }
		println '';
		println 'params';
		params?.each{ println it }
		println '';
		*/
	}

	private def parseDate( date ) {
		if (!date) return null;

		if (date instanceof Date) {
			return date;
		} else {
			return java.sql.Date.valueOf( date );
		}
	}

	private def parseDate( def pattern, def date ) {
		if (!pattern) pattern = "yyyy-MM-dd";

		return parseDate(new SimpleDateFormat(pattern).format(parseDate(date)));
	}

}