package product_type_rules;

import java.util.*;
import java.lang.*;
import java.text.*;
import com.rameses.rules.common.*;
import java.rmi.server.UID;

global RuleAction action;
global List items;
global Map bindings;
global Map bindingsCopy;
global Map paymentCopy;
global Map postingCopy;
global Map loanCopy;

declare References
	executingGroup 			: Boolean
	executingRulegroup		: Boolean
	executingRuleset		: Boolean
	executingAdvancePosting : Boolean
	allowPosting			: Boolean
	allowRepost 			: Boolean
	buildBindings 			: Boolean
	onSupplyValue			: Boolean
	onPostItem 				: Boolean
	loanAppSupplyOnPosting	: Boolean
	isPastDue 				: Boolean
	allowAdvancePosting 	: Boolean
	dbParams				: Map
	totalDays 				: int
end

declare Group
	index 	: int
	sequence: List
end

declare Ruleset
	index	: int
	sequence: List
end

declare Rulegroup
	index 	: int
	sequence: List
end

declare Posting
	index 					: int
	sequence				: List
	values					: Map
	item					: Map
	postingItems			: List
	daysCount 				: int
	incrementAfterPosting 	: Map
	incrementDays 			: Boolean
end

declare Loan 
	index 		: int
	attributes	: List
	bindings 	: Map
	info 		: Map
	
end

declare Payment 
	amount 				: Double
	deductableToAmount	: Double
	date 				: Date
	current 			: Map
	totalPaid 			: Map
	total 				: Map
	lacking 			: Map
	balance 			: Double
	//lacking 			: List
end

declare AdvancePosting
	amount 		: Double
	amountExpr 	: String
	datatype 	: String
	varname 	: String
	fields 		: List
	constraints : List
	expressions : List
	allowPost 	: Boolean
	paid 		: Double
end

function void println( String text ) {
	System.out.println( text );
}

function Date parse( String pattern, Date date ) {
	if (date == null) return null;

	if (pattern == null) pattern = "yyyy-MM-dd";

	String dateStr = new SimpleDateFormat(pattern).format(date);
	return parseDate( dateStr );
}

function Date parseDate( String date ) {
	if (date == null) return null;

	return java.sql.Date.valueOf( date );
}

function Map copyMap( Map src ) {
	Map data = new HashMap();
	//data.putAll( src );
	if (src != null) {
		Iterator itr = 	src.keySet().iterator();

		while (itr.hasNext()) {
			Object k = itr.next();
			if (k != null) {
				Object val = src.get( k.toString() );
				if (val != null) {
					String key = k.toString();
					if (val instanceof Map) {
						data.put( key, copyMap( (Map) val ) );
					} else {
						data.put( key, val );
					}
				}
			}
		}
	}

	return data;	
}

function Boolean findItemById( String id, List list ) {
	Boolean flag = false;
	Object val = null;

	if (list != null && list.size() > 0) {
		if (id != null) {
			for (int i=0; i<list.size(); i++) {
				Map item = (Map) list.get( i );
				if (item.containsKey("objid")) {
					val = item.get("objid");
					if (val != null) {
						if (val.toString().equals( id )) {
							flag = true;
							break;
						}
					}
				}
			}
		}
	}

	return flag;
}

function Map getLastItem( List items ) {
	Map lastitem = new HashMap();

	if (items != null && !items.isEmpty()) {
		lastitem = (Map) items.get( items.size() - 1 );
	}

	return lastitem;
}

function Boolean allowPostItem( Map item ) {
	Boolean flag = false;

	if (item != null && item.containsKey("allowpost")) {
		Object val = item.get("allowpost");
		if (val != null) {
			Boolean f = Boolean.valueOf( val.toString() );
			flag = f;	
		}
	}

	return flag;
}

function Map createPostingItem() {
	Map data = new HashMap();
	data.put("objid", "ITM" + new UID());

	return data;
}

function Map copyLoanInfoByGroup( String group, Map loaninfo, List postingSequence ) {
	List list = new ArrayList();
	Object val = null;

	if (postingSequence != null && !postingSequence.isEmpty()) {
		for (int i=0; i<postingSequence.size(); i++) {
			Map item = (Map) postingSequence.get( i );

			if (item.containsKey("group")) {
				val = item.get("group");
				if (val != null) {
					String g = val.toString();
					if (g.equals( group )) {
						list.add( item );
					}	
				}
			}
		}
	}

	Map info = new HashMap();

	if (loaninfo != null && !loaninfo.isEmpty() && !list.isEmpty()) {
		for (int i=0; i<list.size(); i++) {
			Map item = (Map) list.get( i );
			if (item.containsKey("name")) {
				String name = "";
				val = item.get("name");
				if (val != null) {
					name = val.toString();
				}

				String paidkey = "paid_" + name + "f";
				String totalkey = "total_" + name + "f";
				String savekey = "save_" + name + "f";

				if (loaninfo.containsKey( savekey )) {
					if (loaninfo.containsKey( paidkey )) {
						info.put(paidkey, loaninfo.get( paidkey ));
					}
					if (loaninfo.containsKey( totalkey )) {
						info.put(totalkey, loaninfo.get( totalkey ));
					}
				}
			}
		}
	}

	return info;
}

function Map getAddToBindingsMapByGroupAndRuleset( String group, String ruleset, List sequence, Map values ) {
	//println("sequence->" + sequence);
	//println("group->" + group);

	Map item = new HashMap();
	List list = new ArrayList();
	Object val = null;

	if (sequence != null && !sequence.isEmpty()) {

		for (int i=0; i<sequence.size(); i++) {
			Map d = (Map) sequence.get( i );
			if (d != null) {

				String g = "", rs = "";
				if (d.containsKey("group")) {
					val = d.get("group");
					if (val != null) {
						g = val.toString();
					}
				}

				if (d.containsKey("ruleset")) {
					val = d.get("ruleset");
					if (val != null) {
						rs = val.toString();
					}
				}

				if (g.equals( group ) && rs.equals( ruleset ) && d.containsKey("varname")) {
					list.add( d );
				}
			}
		}
	}

	if (!list.isEmpty()) {
		for (int i=0; i<list.size(); i++) {
			Map d = (Map) list.get( i );
			if (d != null) {
				String name = "";
				if (d.containsKey("name")) {
					val = d.get("name");
					if (val != null) {
						name = val.toString();
					}
					
				}
				//println("seq->" + d.get("name").toString());
				if (values.containsKey( name )) {
					String varname = "";
					val = d.get("varname");
					if (val != null) {
						varname = val.toString();
					}
					String key = group + "_" + varname;
					
					item.put(key, values.get( name ));
				}
			}
		}
	}

	//println("add to bindings->" + item);

	return item;
}

function Map buildValidateConstraintParams( Map item, Map bindings ) {
	Map params = new HashMap();
	Object val = null;

	List fields = new ArrayList();
	if (item.containsKey("fields")) {
		val = item.get("fields");
		if (val != null) {
			fields = (List) val;
		}
	}
	params.put("fields", fields);

	List constraints = new ArrayList();
	if (item.containsKey("constraints")) {
		val = item.get("constraints");
		if (val != null) {
			constraints = (List) val;
		}
	}
	params.put("constraints", constraints);

	Map xbindings = copyMap( bindings );
	params.put("bindings", xbindings);

	return params;
}

rule "execute group"
	salience 160
	when
		r: References( executingGroup == true )
		rs: Ruleset()
		Group( idx: index, list: sequence )
		//eval( idx < list.size() )
		eval( idx < 1 )
	then
		println("execute group");
		rs.setIndex( 0 );

		r.setExecutingGroup( false );
		r.setExecutingRuleset( true );

		update( r );
end

rule "stop rule"
	salience 160
	when
		r: References( executingGroup == true )
		Group( idx: index, list: sequence )
		//eval( idx >= list.size() )
		eval( idx >= 1 )
	then
		println("stop rule");
end

rule "execute ruleset"
	salience 150
	when
		r: References( executingRuleset == true )
		rg: Rulegroup()
		Ruleset( idx: index, list: sequence )
		//eval( idx < list.size() )
		eval( idx < 1 )
	then
		println("execute ruleset");
		rg.setIndex( 0 );
		//rs.setIndex( idx + 1 );
		//update( rs );

		r.setExecutingRuleset( false );
		r.setExecutingRulegroup( true );
		update( r );
end

rule "increment group"
	salience 150
	when
		r: References( executingRuleset == true )
		g: Group( gidx: index )
		Ruleset( idx: index, list: sequence )
		//eval( idx >= list.size() )
		eval( idx >= 1 )
	then
		g.setIndex( gidx + 1 );

		r.setExecutingRuleset( false );
		r.setExecutingGroup( true );
		update( r );
end

rule "execute rulegroup"
	salience 140
	when
		r: References( executingRulegroup == true )
		l: Loan()
		Rulegroup( idx: index, list: sequence )
		//eval( idx < list.size() )
		eval( idx < 1 )
	then
		l.setIndex( 0 );

		r.setExecutingRulegroup( false );
		r.setLoanAppSupplyOnPosting( true );
		update( r );
end

rule "increment ruleset"
	salience 140
	when
		r: References( executingRulegroup == true )
		rs: Ruleset( rsidx: index )
		Rulegroup( idx: index, list: sequence )
		//eval( idx >= list.size() )
		eval( idx >= 1 )
	then
		rs.setIndex( rsidx + 1 );

		r.setExecutingRulegroup( false );
		r.setExecutingRuleset( true );
		update( r );
end

rule "supply loan value"
	salience 110
	when
		r: References( loanAppSupplyOnPosting == true )
		l: Loan( idx: index, list: attributes )
		//eval( idx < list.size() )
		eval( idx < 1 )
	then
		//Map item = (Map) list.get( idx );
		//println("item-> " + item);

		//if (item.containsKey("attribute")) {
		//	println("attr->" + item.get("attribute"));
		//}

		//l.setIndex( idx + 1 );
		//update( l );
		r.setLoanAppSupplyOnPosting( false );
		r.setOnPostItem( true );
		update( r );
end


rule "increment rulegroup"
	salience 110
	when
		r: References( loanAppSupplyOnPosting == true )
		rg: Rulegroup( rgidx: index )
		Loan( idx: index, list: attributes )
		//eval( idx >= list.size() )
		eval( idx >= 1 )
	then
		rg.setIndex( rgidx + 1 );

		r.setLoanAppSupplyOnPosting( false );
		r.setExecutingRulegroup( true );
		update( r );
end

rule "posting: item"
	salience 100
	when
		r: References( onPostItem == true )
		p: Posting( idx: index, list: sequence )
		eval( idx < list.size() )
		//eval( idx < 1 )
	then
		Map item = (Map) list.get( idx );
		if (item.containsKey("header")) {
			println("posting item->" + item.get("header"));
		}

		p.setIndex( idx + 1 );
		update( p );
end

rule "increment supply loan value"
	salience 100
	when
		r: References( onPostItem == true )
		l: Loan( lidx: index )
		Posting( idx: index, list: sequence )
		eval( idx >= list.size() )
		//eval( idx >= 1 )
	then
		l.setIndex( lidx + 1 );

		r.setOnPostItem( false );
		r.setLoanAppSupplyOnPosting( true );
		update( r );
end