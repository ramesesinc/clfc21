import com.rameses.common.*;
import com.rameses.annotations.*;
import com.rameses.services.extended.*;
import com.rameses.rules.common.*;
import java.rmi.server.UID;
import loan.facts.*;
import loan.actions.*;
import java.util.*;
import com.rameses.util.*;
import java.text.*;

class LoanLedgerBillingService extends ActiveListService
{
	@Env
	def env;

	@ActiveDB("ledger_billing")
	def em;

	@ActiveDB("ledger_billing_assist")
	def billing_assist;

	@ActiveDB("calendar_event")
	def calendar_event;

	@ActiveDB("loan_ledger")
	def loan_ledger;

	@ActiveDB("loan_ledger_payment")
	def ledger_payment;

	@ActiveDB("loan_product_type")
	def product_type;

	@ActiveDB("loan_exemption")
	def exemption;

	@ActiveDB("fieldcollection")
	def fieldcollection;

	@ActiveDB("loanapp")
	def loanapp;

	@ActiveDB("loan_route")
	def loan_route;

	@ActiveDB("loan_ledger_compromise")
	def ledger_compromise;

	@ActiveDB("collection_remittance")
	def remittance;

	@ActiveDB("amnesty")
	def amnesty;

	@ActiveDB("billing_process")
	def process;

	@ActiveDB("ledger_billing_cancelrequest")
	def ledger_billing_cancelrequest;

	@ActiveDB("var")
	def var;

	@ActiveDB("customer")
	def customer;

	@ActiveDB("customerindividual")
	def customerindividual;

	@ActiveDB("loanapp_borrower")
	def loanapp_borrower;

	@ActiveDB("ledgeramnesty")
	def ledgeramnesty;

	@ActiveDB("ledgeramnesty_fix")
	def ledgeramnesty_fix;

	@Service("DateService")
	def dateSvc;

	@Service("SequenceService")
	def seqSvc;

	@Service("CalendarEventService")
	def calendarSvc;

	@Service("LoanLedgerService")
	def ledgerSvc;

	@Service("BranchService")
	def branchSvc;

	@Service("RuleExecutorService")
	def ruleSvc;

	@Service("NumberService")
	def numSvc;

	@Service("InboxService")
	def inboxSvc;

	@Service
	def selfSvc;
		
	private def DATE_FORMAT1 = new SimpleDateFormat("MMMMM dd, yyyy");
	private def DATE_FORMAT2 = new SimpleDateFormat("MMM-dd-yyyy hh:mm:ss a");
	private def DEC_FORMAT = new DecimalFormat("#,##0.00");

	@ProxyMethod
	public def getNodes( params) {
		return [
			[caption: 'DRAFT', state: 'DRAFT'], 
			[caption: 'FOR_DOWNLOAD', state: 'FOR_DOWNLOAD'],
			[caption: 'CANCELLED', state: 'CANCELLED'], 
			[caption: 'COMPLETED', state: 'COMPLETED'],
			[caption: 'UNREMITTED', state: 'UNREMITTED'],
			[caption: 'UNPOSTED', state: 'UNPOSTED'],
			[caption: 'UPLOADED', state: 'UPLOADED'],
			[caption: 'VOIDED', state: 'VOIDED']
		];
	}

	@ProxyMethod
	public def getOptions() {
		return [
			[caption: 'FOR DOWNLOAD', state: 'FOR_DOWNLOAD'],
			[caption: 'DOWNLOADED', state: 'DOWNLOADED'],
			[caption: 'REMITTED', state: 'REMITTED'],
			[caption: 'POSTED', state: 'POSTED'],
			[caption: 'PENDING CANCEL REQUEST', state: 'PENDING_CANCEL_REQUEST'],
			[caption: 'FOR APPROVAL CANCEL REQUEST', state: 'FOR_APPROVAL_CANCEL_REQUEST'],
			[caption: 'CANCELLED', state: 'CANCELLED'],
			[caption: 'CLOSED', state: 'CLOSED'],
		];
	}

	@ProxyMethod
	public def getColumns( params ) {
		def cols = [];

		cols << [name: 'collector.name', caption: 'Collector'];
		cols << [name: 'route.name', caption: 'Route', minWidth: '120'];
		cols << [name: 'billdate', caption: 'Billing Date', type: 'date', outputFormat: 'MMM-dd-yyyy'];

		return cols;
	}

	void beforeList( params ) {
		params.searchtext = (params.searchtext? params.searchtext : '') + '%';
		if (params.state) {
			params._listMethod = 'getRouteListByState';
		}
		/*
		if (params.state == 'REMITTED') {
			params._listMethod = 'getRemittedRouteList';
		}
		if (params.state == 'POSTED') {
			params._listMethod = 'getPostedRouteList';
		}
		*/
	}

	void afterList( params, list ) {
		list.each{ it.filetype = 'ledgerbilling' }
	}

	public void validateBilling( data ) {
		def i = remittance.findUnpostedRemittance();
		if (i) throw new Exception("Cannot create billing. There are still unposted collections.");

		def date = dateSvc.format("yyyy-MM-dd", dateSvc.serverDate);
		if (java.sql.Date.valueOf(data.billdate) < java.sql.Date.valueOf(date)) 
			throw new Exception("Billing date must be greater than or equal to current date.");

		def sysvar = var.read([name: "allow_sunday_billing"]);
		if (!sysvar || sysvar.value != 'true') {			
			Calendar c = Calendar.getInstance();
			c.setTime(parseDate(data.billdate));
			//c.setTime(java.sql.Date.valueOf(data.billdate));
			if (c.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) 
				throw new Exception('Cannot create billing. Billing date is a sunday.');
		}

		sysvar = var.read([name: "allow_holiday_billing"])
		if (!sysvar || sysvar.value != 'true') {			
			def d = calendar_event.findByDate([date: data.billdate]);
			if (d) throw new Exception('Cannot create billing. Billing date is a holiday.');
		}

		if (!data?.routes) throw new Exception('At least 1 route to bill is required.');

		data?.routes?.each{ o->
			i = em.findByBilldateAndItemid([billdate: data.billdate, itemid: o.code]);
			//println 'parentid ' + i;
			if (i && i.parentid != data.objid) {
				def msg = 'Cannot create billing. Billing for route ' + o.description + ' - ' + o.area + ' already created\n';
				msg += ' and assigned to collector ' + i.collector?.name + '.';
				throw new RuntimeException(msg);
				//throw new Exception("Cannot create billing. Billing for route " + o.description + " - " + o.area + " already created and assigned to collector " + i.collector?.name + ".");
			}
		}

		/*
		def params = [billdate: data.billdate];
		data._added.each{ o->
			params.itemid = o.code;
			def d = em.findByBilldateAndItemid(params);
			if (d) throw new Exception("Cannot create billing. Billing for route " + o.description + " - " + o.area + " already created.");
		}
		*/

	}

	@Async
	@ProxyMethod
	public def create( data ) {
		validateBilling(data);

		def branch = branchSvc.open([:]);
		def xdata = em.findByCollectorAndBilldate([collectorid: data?.collector?.objid, date: data?.billdate]);
		if (!xdata) {
			data.branchid = branch?.code;
			data.dtcreated = dateSvc.serverDate;
			data.author = [objid: env.USERID, name: env.NAME];
			data.totalfordownload = 0;
			data.totaldownloaded = 0;
			data.totalposted = 0;

			em.create(data);
		} else if (xdata) {
			data.putAll(xdata);
		}

		updateBillingItem(data);
		if (!data.state) data.state = 'FOR_DOWNLOAD';

		return open(data);
	}

	@Async
	@ProxyMethod(local=true)
	public def update( data ) {
		validateBilling(data);
		def updateprevdata = false;

		def previd = data?.objid;

		def branch = branchSvc.open([:]);
		def params = [collectorid: data?.collector?.objid, date: data?.billdate];
		def xdata = em.findByCollectorAndBilldate(params);
		if (!xdata) {
			data.objid = 'LB' + new UID();
			data.branchid = branch?.code;
			data.dtcreated = dateSvc.serverDate;
			data.author = [objid: env.USERID, name: env.NAME];
			data.totalfordownload = 0;
			data.totaldownloaded = 0;
			data.totalposted = 0;

			em.create(data);
		} else if (xdata) {
			data.putAll(xdata);
			updateprevdata = true;
		}

		def item;
		data?.routes?.each{ o->
			item = em.read([objid: o.itemid], 'billing-item');
			if (item) {
				item.parentid = data?.objid;
				em.update(item, 'billing-item');

				em.updateBillingDetailBillingidByParentid([parentid: item?.objid, billingid: data?.objid]);
			}
		}

		em.update(data);
		data.prevdataid = previd;
		updateBillingItem(data);
		if (!data.state) data.state = 'FOR_DOWNLOAD';

		return open(data);
	}


	/*
	void beforeUpdate( data ) {
		validateBilling(data);
	}
	*/

	/*
	private void setFlags( data ) {
		data.totalfordownload = em.getRoutes(data).size();//data.routes.size();
		data.totaldownloaded = 0;
		data.totalposted = 0;
	}
	*/

	/*void afterCreate( data ) {
		updateBillingItem(data);
	}*/

	/*
	void afterUpdate( data ) {
		//em.removeBillingDetailByBillingid(data);
		updateBillingItem(data);
	}
	*/

	void updateBillingItem( data ) {

		def item, list;
		data?._removed?.each{ o->
			//println 'item ' + o;
			//item = em.findByBillingidAndItemid([objid: data.objid, itemid: o.code]);
			item = em.read([objid: o.itemid], 'billing-item');
			if (item) {
				em.removeBillingDetail(item);
				em.delete(item, 'billing-item');
			}
		}

		data?._added?.each{ o->
			item = em.findByBillingidAndItemid([objid: data.objid, itemid: o.code]);
			if (!item || item.state == 'CANCELLED') {
				item = [
					objid	 	: o.itemid,
					parentid 	: data.objid,
					state 		: 'FOR_DOWNLOAD',
					dtmodified 	: dateSvc.serverDate,
					modifiedby 	: [objid: env.USERID, name: env.NAME],
					item 		: [objid: o.code, type: 'route']
				];
				em.create(item, 'billing-item');

				o.billdate = data.billdate;
				o.billingid = data.objid;
				createBillingByRoute(o);
			}
		}

		def items = em.getBillingItems(data);
		data.totalfordownload = items.findAll{ it.state == 'FOR_DOWNLOAD' }.size();
		em.update(data, "fordownload");

		data.totaldownloaded = items.findAll{ it.state == 'DOWNLOADED' }.size();
		em.update(data, "downloaded");

		def xlist = items.findAll{ it.state!='FOR_DOWNLOAD' && it.state!='DOWNLOADED' }
		xlist.each{ o->
			def rem = remittance.findCollectionRemittance([collectionid: o.parentid, groupid: o.item.objid, grouptype: o.item.type]);
			if (rem && rem.state == 'POSTED') {
				if (!data.totalposted) data.totalposted = 0;
				data.totalposted++;
			} 
		}
		em.update(data, "posted");

		if (data?.prevdataid) {
			def xdata = em.read([objid: data?.prevdataid]);

			items = em.getBillingItems(xdata);
			xdata.totalfordownload = items.findAll{ it.state == 'FOR_DOWNLOAD' }.size();
			em.update(xdata, "fordownload");

			xdata.totaldownloaded = items.findAll{ it.state == 'DOWNLOADED' }.size();
			em.update(xdata, "downloaded");

			xlist = items.findAll{ it.state!='FOR_DOWNLOAD' && it.state!='DOWNLOADED' }
			xlist.each{ o->
				def rem = remittance.findCollectionRemittance([collectionid: o.parentid, groupid: o.item.objid, grouptype: o.item.type]);
				if (rem && rem.state == 'POSTED') {
					if (!xdata.totalposted) data.totalposted = 0;
					xdata.totalposted++;
				} 
			}
			em.update(xdata, "posted");
		}

		data.editable = true;
		data.forsubbilling = true;
	}


	void createBillingByRoute( route ) {
		def _size = 20, _limit = _size, _page = 1, _start = 0;

		def actions = new RuleAction(); 
		actions.addCommand( "calcInterest", new  CalculateBillingInterest(NS: numSvc) );
		actions.addCommand( "calcPenalty", new  CalculateBillingPenalty(NS: numSvc) );
		actions.addCommand( "calcOthers", new CalculateBillingOthers(NS: numSvc) );
		actions.addCommand( "calcAmountDue", new CalculateBillingAmountDue(NS: numSvc) );
		actions.addCommand( "calcBalance", new CalculateBillingBalance(NS: numSvc) );

		def cd = parseDate(route.billdate);
		def list = [], facts, details, size;
		/*
		def params = [
			route_code	: route.code,
			_rowsize	: _limit, 
			_limit		: _limit
		];
		*/

		list = loan_ledger.getCollectionsheets([route_code: route.code]);
		list = resolveBorrowerNextto(list)

		while (true) {
			_start = (_page*_limit)-_limit;
			size = ((_page*_limit) < list.size()? (_page*_limit) : list.size());

			facts = [];
			details = [];
			facts << new CurrDate([currentdate: cd]);

			for (int i=_start; i<size; i++) {
				def xitem = list[i];
				if (!xitem.dtreleased) {
					def ac = loanapp.read([objid: xitem.loanappid], 'loanapp_capture');
					if (ac) {
						xitem.dtreleased = ac.dtreleased;
					}
				}
				xitem.route = route;
				xitem.itemid = route?.itemid;
				xitem.billingid = route?.billingid;
				xitem.billdate = route?.billdate;

				def item = createItem(xitem);
				facts << buildLedgerFact(item);
				facts << buildLoanappFact(item);
				facts << buildBillingItemFact(item);
				facts << buildAmnestyFact(item);
				details << item;
			}

			ruleSvc.execute( 'loanbilling', facts, actions, null );

			details?.each{ o->
				def bi = facts?.find{ (it instanceof LoanBillingItem && o.ledgerid == it.ledgerid) }

				o.penalty = bi?.penalty;
				o.others = bi?.others;
				o.amountdue = bi?.amountdue;
				o.balance = bi?.balance;

				def li = loan_ledger.findLastLedgerItemByParentId([parentid: o.ledgerid]);		

				if (li?.interestbal > 0) {
					o.amountdue += li?.interestbal;
					o.balance += li?.interestbal;
					o.interest += li?.interestbal;
				}

				if (li?.penaltybal > 0) {
					o.amountdue += li?.penaltybal;
					o.balance += li?.penaltybal;
					o.penalty += li?.penaltybal;
				}
				em.create(o, 'billing-detail');

			}

			if ((size + 1) > (_page*_limit)) {
				_page++;
			} else {
				break;
			}
		}

		/*
		while (true) {
			facts = [];
			details = [];
			facts << new CurrDate([currentdate: cd]);

			params._start = _size * (_page - 1);
			params._toprow = params._start;
			list = loan_ledger.getCollectionsheets(params);


			def s = (list?.size() > _size? _size : list?.size());
			for (def i=0; i<s; i++) {
				def xitem = list[i];
				if (!xitem.dtreleased) {
					def ac = loanapp.read([objid: xitem.loanappid], 'loanapp_capture');
					if (ac) {
						xitem.dtreleased = ac.dtreleased;
					}
				}
				xitem.route = route;
				xitem.itemid = route?.itemid;
				xitem.billingid = route?.billingid;
				xitem.billdate = route?.billdate;

				def item = createItem(xitem);
				facts << buildLedgerFact(item);
				facts << buildLoanappFact(item);
				facts << buildBillingItemFact(item);
				facts << buildAmnestyFact(item);
				details << item;
			}
			
			ruleSvc.execute( 'loanbilling', facts, actions, null );

			details?.each{ o->
				def bi = facts?.find{ (it instanceof LoanBillingItem && o.ledgerid == it.ledgerid) }

				o.penalty = bi?.penalty;
				o.others = bi?.others;
				o.amountdue = bi?.amountdue;
				o.balance = bi?.balance;

				def li = loan_ledger.findLastLedgerItemByParentId([parentid: o.ledgerid]);		

				if (li?.interestbal > 0) {
					o.amountdue += li?.interestbal;
					o.balance += li?.interestbal;
					o.interest += li?.interestbal;
				}

				if (li?.penaltybal > 0) {
					o.amountdue += li?.penaltybal;
					o.balance += li?.penaltybal;
					o.penalty += li?.penaltybal;
				}
				em.create(o, 'billing-detail');

			}

			if (list?.size() > _size) {
				_page++;
			} else {
				break;
			}
		}
		*/
	}


	def resolveBorrowerNextto( srclist ) {
		def list = [];
		while (true) {			
			def item = srclist.find{ it.isstart==1 }
			if (!item) item = srclist.find{ it.nextto != null };
			if (!item) break;

			def previtem;
			while (item?.nextto != null) {
				previtem = item;
				item = srclist?.find{ it.acctid == item.nextto }
				if (!item) {
					item = previtem;
					break;
				}
			}

			def xitmlist;
			while (item != null) {
				xitmlist = srclist.findAll{ it.acctid == item.acctid }
				xitmlist?.sort{ it.appno }
				xitmlist?.each{ xitm->
					list << xitm;
					srclist.remove(xitm);
				}
				item = srclist?.find{ it.nextto == item.acctid }
			}
		}

		if (srclist) list.addAll(srclist);

		return list;
	} 

	def createItem( item ) {
		def cd = parseDate(item.billdate);
		if (item.dtmatured) {
			def md = parseDate(item.dtmatured);

			if (cd.compareTo(md) > 0 && !item.overduepenalty && item.balance > 0) {
				def p = product_type.read([name: item.producttypeid]);
				def rate = p.pastduerate? p.pastduerate : 0;
				item.overduepenalty = ledgerSvc.computeOverduePenalty([balance: item.balance, pastduerate: rate]);
				loan_ledger.update(item, 'overduepenalty');
			}
		}

		def xp = ledger_payment.findByParentid([parentid: item.objid]);

		def detail = [
			objid				: 'LLBD' + new UID(),
			parentid 			: item?.itemid,
			billingid 			: item?.billingid,
			ledgerid 			: item?.objid,
			route_code 			: item?.route?.code,
			acctid 				: item?.acctid,
			loanappid 			: item?.loanappid,
			acctname 			: item?.acctname,
			loanamount 			: item?.loanamount,
			loandate 			: item?.loandate,
			term 				: item?.term,
			appno 				: item?.appno,
			overpaymentamount 	: item?.overpaymentamount,
			txndate 			: cd,
			dailydue 			: item?.dailydue,
			dtreleased 			: item?.dtreleased,
			dtmatured 			: item?.dtmatured,
			producttypeid 		: item?.producttypeid,
			paymentmethod 		: item?.paymentmethod,
			interestamount 		: item?.interestamount,
			homeaddress 		: item?.homeaddress,
			collectionaddress 	: item?.collectionaddress? item?.collectionaddress : '',
			interest 			: 0,
			others 				: 0,
			overduepenalty 		: item?.overduepenalty,
			isfirstbill 		: xp? 0 : 1
		];

		detail.refno = getRefno([routecode: item?.route?.code]);

		return detail;
	}

	void xupdateBillingItem( data ) {
		def item;
		def list;
		data._removed.each{ o->
			item = em.findByBillingidAndItemid([objid: data.objid, itemid: o.code]);
			if (item) {
				em.removeBillingDetail(item);
				em.delete(item, "billing-item");
			}
		}
		//em.removeForDownloadBillingItemByType([objid: data.objid, type: 'route']);
		data._added.each{ o->
			item = [
				objid 		: 'LI' + new UID(),
				parentid 	: data.objid,
				state 		: 'FOR_DOWNLOAD',
				dtmodified	: dateSvc.serverDate,
				modifiedby 	: [objid: env.USERID, name: env.NAME],
				item 		: [objid: o.code, type: 'route']
			];
			em.create(item, "billing-item");
			item.billdate = data.billdate;

			em.removeBillingDetail(item);
			//process.create(item);
			list = loan_ledger.getCollectionsheets([route_code: o.code]);
			/*
			list.each{ l->
				process.create([ objid: l.objid, parentid: item.objid ], "detail");
			}
			*/
			createBillingByRoute(list, item, o);
		}

		def items = em.getBillingItems(data);
		data.totalfordownload = items.findAll{ it.state == 'FOR_DOWNLOAD' }.size();
		em.update(data, "fordownload");

		data.totaldownloaded = items.findAll{ it.state == 'DOWNLOADED' }.size();
		em.update(data, "downloaded");

		def xlist = items.findAll{ it.state!='FOR_DOWNLOAD' && it.state!='DOWNLOADED' }
		xlist.each{ o->
			def rem = remittance.findCollectionRemittance([collectionid: o.parentid, groupid: o.item.objid, grouptype: o.item.type]);
			if (rem && rem.state == 'POSTED') {
				if (!data.totalposted) data.totalposted = 0;
				data.totalposted++;
			} 
		}
		em.update(data, "posted");

		data.editable = true;
		data.forsubbilling = true;
	}

	/*
	void updateBillingDetail( data ) {
		em.removeBillingDetailByParentid([parentid: data.objid]);
		process.create([ objid: data.objid ]);
		data.routes.each{route->
			def list = loan_ledger.getCollectionsheets([route_code: route.code]);
			list.each{
				process.create([ objid: it.objid, parentid: data.objid ], "detail");
			}
			selfSvc.createBillingByRoute(list, data, route);
			//createBilling(list, data, route);
		}
	}

	@ProxyMethod(local=true)
	public void removeProcessDetailByPrimary( objid ) {
		process.delete([objid: objid], "detail");
	}

	@ProxyMethod(local=true)
	public def getProductType( producttypeid ) {
		return product_type.read([name: producttypeid]);
	}

	@ProxyMethod(local=true)
	public def updateLedgerOverduePenalty( ledger ) {
		loan_ledger.update(ledger, 'overduepenalty');
		return ledger;
	}

	@ProxyMethod
	public def getNoOfDaysExempted( startdate, enddate, ledgerid ) {
		def params = [
			startdate 	: startdate,
			enddate 	: enddate,
			ledgerid 	: ledgerid
		];
		def e = exemption.findTotaldaysExemptedByStartdateAndEnddateAndLedgerid(params);
		return (e.totaldays? e.totaldays : 0);
	}
	*/

	private void xcreateBillingByRoute( list, entity, route ) {
		def _page = 1, _start = 0, _limit = 10;
		def facts, details, item, size, xitem;

		def actions = new RuleAction(); 
		actions.addCommand( "calcInterest", new  CalculateBillingInterest(NS: numSvc) );
		actions.addCommand( "calcPenalty", new  CalculateBillingPenalty(NS: numSvc) );
		actions.addCommand( "calcOthers", new CalculateBillingOthers(NS: numSvc) );
		actions.addCommand( "calcAmountDue", new CalculateBillingAmountDue(NS: numSvc) );
		actions.addCommand( "calcBalance", new CalculateBillingBalance(NS: numSvc) );

		def currentDate = dateSvc.parse("yyyy-MM-dd", entity.billdate);
		while (true) {
			facts = [];
			details = [];
			facts << new CurrDate([currentdate: currentDate]);
			_start = (_page*_limit)-_limit;
			size = ((_page*_limit) < list.size()? (_page*_limit) + 1: list.size());
			for (int i=_start; i<size; i++) {
				if (i < (_page*_limit)) {
					xitem = list[i];
					if (!xitem.dtreleased) {
						def ac = loanapp.read([objid: xitem.loanappid], 'loanapp_capture');
						if (ac) {
							xitem.dtreleased = ac.dtreleased;
						}
					}
					item = createItem(entity, xitem, route);
					facts << buildLedgerFact(item);
					facts << buildLoanappFact(item);
					facts << buildBillingItemFact(item);
					facts << buildAmnestyFact(item);
					details << item;
					//println list[i]?.objid
					//processSegregation(list[i], currentdate);
				}
			}

			ruleSvc.execute( "loanbilling", facts, actions, null );

			details.each{ o->

				def billitem = facts.find{ (it instanceof LoanBillingItem && o.ledgerid == it.ledgerid) }
				//println 'bill item ' + billitem;
				o.penalty = billitem.penalty;
				o.others = billitem.others;
				o.amountdue = billitem.amountdue;
				o.balance = billitem.balance;

				def ledgeritem = loan_ledger.findLastLedgerItemByParentId([parentid: o.ledgerid]);		

				if (ledgeritem?.interestbal > 0) {
					o.amountdue += ledgeritem.interestbal;
					o.balance += ledgeritem.interestbal;
					o.interest += ledgeritem.interestbal;
				}

				if (ledgeritem?.penaltybal > 0) {
					o.amountdue += ledgeritem.penaltybal;
					o.balance += ledgeritem.penaltybal;
					o.penalty += ledgeritem.penaltybal;
				}
				em.create(o, "billing-detail");
			}

			if (size > (_page*_limit)) {
				_page++;
			} else {
				break;
			}
		}

		/*
		list.each{
			calculateBilling(entity, it, route);			
		}
		*/

	}

	private def xxcreateItem( entity, item, route ) {		
		def days = 0;

		def currentDate = dateSvc.parse("yyyy-MM-dd", entity.billdate);
		def maturityDate;
		if (item.dtmatured) {
			maturityDate = dateSvc.parse("yyyy-MM-dd", item.dtmatured);
		} 
		if (maturityDate && currentDate >  maturityDate && item.overduepenalty == 0.00 && item.balance > 0) {
			def p = product_type.read([name: item.producttypeid]);
			item.overduepenalty = ledgerSvc.computeOverduePenalty([balance: item.balance, pastduerate: (p.pastduerate? p.pastduerate : 0.00)]);
			loan_ledger.update(item, 'overduepenalty');
		}
		def xpayment = ledger_payment.findByParentid([parentid: item.objid]);
		def detail = [
			objid				: 'LLBD' + new UID(),
			parentid 			: entity.objid,
			billingid 			: entity.parentid,
			ledgerid 			: item.objid,
			route_code 			: route? route.code : item.route.code,
			acctid 				: item.acctid,
			loanappid 			: item.loanappid,
			acctname 			: item.acctname,
			loanamount 			: item.loanamount,
			loandate 			: item.loandate,
			term 				: item.term,
			appno 				: item.appno,
			overpaymentamount 	: item.overpaymentamount,
			txndate 			: currentDate,
			dailydue 			: item.dailydue,
			dtreleased			: item.dtreleased,
			dtmatured 			: item.dtmatured,
			producttypeid 		: item.producttypeid,
			paymentmethod 		: item.paymentmethod,
			interestamount 		: item.interestamount,
			homeaddress 		: item.homeaddress,
			collectionaddress 	: item.collectionaddress? item.collectionaddress : '',
			interest 			: 0.00,
			others 				: 0.00,
			overduepenalty 		: item.overduepenalty,
			isfirstbill			: (xpayment? 0 : 1)
		];
		//detail.refno = 'B'+seqSvc.getNextFormattedSeriesA('loanbill-'+detail.route_code, 8);
		detail.refno = getRefno([routecode: detail.route_code]);

		return detail;
	}

	private void calculateBilling( entity, item, route ) {
		def days = 0;

		def currentDate = dateSvc.parse("yyyy-MM-dd", entity.billdate);
		def maturityDate = dateSvc.parse("yyyy-MM-dd", item.dtmatured);
		if (currentDate >  maturityDate && item.overduepenalty == 0.00) {
			def p = product_type.read([name: producttypeid]);
			item.overduepenalty = ledgerSvc.computeOverduePenalty([balance: item.balance, pastduerate: (p.pastduerate? p.pastduerate : 0.00)]);
			loan_ledger.update(item, 'overduepenalty');
		}
		def detail = [
			objid				: 'LLBD'+new UID(),
			parentid 			: entity.objid,
			billingid 			: entity.parentid,
			ledgerid 			: item.objid,
			route_code 			: route? route.code : item.route.code,
			acctid 				: item.acctid,
			loanappid 			: item.loanappid,
			acctname 			: item.acctname,
			loanamount 			: item.loanamount,
			loandate 			: item.loandate,
			term 				: item.term,
			appno 				: item.appno,
			overpaymentamount 	: item.overpaymentamount,
			txndate 			: currentDate,
			dailydue 			: item.dailydue,
			dtreleased			: item.dtreleased,
			dtmatured 			: item.dtmatured,
			producttypeid 		: item.producttypeid,
			paymentmethod 		: item.paymentmethod,
			interestamount 		: item.interestamount,
			homeaddress 		: item.homeaddress,
			collectionaddress 	: item.collectionaddress? item.collectionaddress : '',
			interest 			: 0.00,
			others 				: 0.00,
			overduepenalty 		: item.overduepenalty,
			isfirstbill			: (item.balance == item.loanamount? 1 : 0)
		];
		//detail.refno = 'B'+seqSvc.getNextFormattedSeriesA('loanbill-'+detail.route_code, 8);
		detail.refno = getRefno([routecode: detail.route_code]);

		def facts = [];
		facts << new CurrDate([currentdate: currentDate]);
		facts << buildLedgerFact(detail);
		facts << buildLoanappFact(detail);
		facts << buildBillingItemFact(detail);

		def actions = new RuleAction(); 
		actions.addCommand( "calcInterest", new  CalculateBillingInterest(NS: numSvc) );
		actions.addCommand( "calcPenalty", new  CalculateBillingPenalty(NS: numSvc) );
		actions.addCommand( "calcOthers", new CalculateBillingOthers(NS: numSvc) );
		actions.addCommand( "calcAmountDue", new CalculateBillingAmountDue(NS: numSvc) );
		actions.addCommand( "calcBalance", new CalculateBillingBalance(NS: numSvc) );

		ruleSvc.execute( "loanbilling", facts, actions, null );

		def billitem = facts.find{ (it instanceof LoanBillingItem) }
		detail.penalty = billitem.penalty;
		detail.others = billitem.others;
		detail.amountdue = billitem.amountdue;
		detail.balance = billitem.balance;

		def ledgeritem = loan_ledger.findLastLedgerItemByParentId([parentid: detail.ledgerid]);		
		if (ledgeritem?.interestbal > 0) {
			detail.amountdue += ledgeritem.interestbal;
			detail.balance += ledgeritem.interestbal;
			detail.interest += ledgeritem.interestbal;
		}
		if (ledgeritem?.penaltybal > 0) {
			detail.amountdue += ledgeritem.penaltybal;
			detail.balance += ledgeritem.penaltybal;
			detail.penalty += ledgeritem.penaltybal;
		}
		//detail.refno 

		/*def amt = item.dailydue;
		if (item.paymentmethod == 'over' && item.overpaymentamount > 0) amt = item.overpaymentamount; 
		days = dateSvc.getDaysDiff(item.dtcurrentschedule, currentDate);
		detail.amountdue = (amt*days)+detail.others;
		if (!item.compromiseid) {	
			def req = new RuleRequest("billing");
			def referencesFact = [					
				isFixed				: false,
				isOverdue			: (currentDate > maturityDate),
				hasSunday			: false,
				balance				: item.balance,
				absentPenalty		: item.absentpenalty,
				overduePenalty		: detail.overduepenalty,
				dailyDue			: amt,
				interest 			: detail.interestamount,
				overpayment			: item.overpaymentamount,
				others				: detail.others,
				totalDays			: days
			];
			req.addFact("billing", "References", referencesFact);
			req.addGlobal("detail", detail);
			referencesFact.noOfHolidays = calendarSvc.getNoOfHolidays([lastscheduledate: item.dtcurrentschedule, item:[trialAndError: 0, totalDays: days]]);
			referencesFact.noOfDaysExempted = selfSvc.getNoOfDaysExempted(item.dtcurrentschedule, currentDate,  item.objid);
			
			def cal = Calendar.getInstance();
			cal.setTime(dateSvc.add(currentDate, "-"+referencesFact.noOfHolidays));
			if ((cal.get(cal.DAY_OF_WEEK)-1) == 1) {
				referencesFact.hasSunday = true;
			}

			ruleSvc.execute(req);
			if (detail.penalty) {
				detail.penalty = new BigDecimal(detail.penalty+'').setScale(2, BigDecimal.ROUND_HALF_UP);
			}

			if (detail.amountdue) {
				detail.amountdue = new BigDecimal(detail.amountdue+'').setScale(0, BigDecimal.ROUND_CEILING);
			}
			detail.balance = selfSvc.getBalance(detail, item.balance);
		} else {

		}*/
		em.create(detail, "billing-detail");
		//selfSvc.removeProcessDetailByPrimary(detail.ledgerid);
	}

	@ProxyMethod(local=true)
	public def getRefno( params ) {
		if (!params.routecode) throw new Exception("Please specify routecode.");
		
		def branch = branchSvc.open([:]);

		def refno = (branch?.code? branch.code : '') + 'P';
		def date = dateSvc.serverDate.toString().split(" ")[0];//java.sql.Date.valueOf(dateSvc.serverDate);
		Calendar c = Calendar.getInstance();
		c.setTime(java.sql.Date.valueOf(date));
		def year = c.get(Calendar.YEAR) + ''; 
		//println c.get(Calendar.YEAR);
		refno += year[2] + year[3];
		def r = loan_route.read([code: params.routecode]);
		if (!r?.prefix) 
			throw new Exception("Please specify prefix for route code " + params.routecode);
		refno += r.prefix;
		refno += seqSvc.getNextFormattedSeriesA('loanbill-' + year + '-' + params.routecode, 6);
		return refno;
	}

	private def parse( pattern, date ) {
		if (!pattern) pattern = "yyyy-MM-dd";
		def dt;
		if (date instanceof Date) {
			dt = date;
		} else {
			dt = java.sql.Date.valueOf(date);
		}
		return new java.text.SimpleDateFormat(pattern).format(dt);
	}

	private def parseDate( date ) {
		if (!date) return null;

		if (date instanceof Date) {
			return date;
		} else {
			return java.sql.Date.valueOf(date);
		}
	}

	public def buildLedgerFact( params ) {
		def data = loan_ledger.read([objid: params.ledgerid]);
		def lastitem = loan_ledger.findLastLedgerItemByParentId([parentid: params.ledgerid]);
		def item = [
			ledgerid 		: data.objid,
			appid 			: data.appid,
			dtmatured		: data.dtmatured,
			dtrelease 		: DateUtil.add(data.dtstarted, "-1"),
			dtstarted		: data.dtstarted,
			dtlastpaid 		: data.dtlastpaid,
			currentdate 	: params.txndate,
			balance 		: data.balance,
			overduepenalty 	: data.overduepenalty,
			balance 		: data.balance,
			overpayment 	: data.overpaymentamount,
			hasamnesty 		: false,
			paymentmethod 	: data.paymentmethod,
			lackinginterest : lastitem?.interestbal,
			lackingpenalty 	: lastitem?.penaltybal
		];
		def am = amnesty.findActiveAmnestyByLedgeridAndDate([ledgerid: data.objid, date: parse("yyyy-MM-dd", params.txndate)]);
		if (am) item.hasamnesty = true;
		return new LoanLedger(item);
	}

	public def buildLoanappFact( params ) {
		def data = loan_ledger.read([objid: params.ledgerid]);
		def producttype = product_type.read([name: data.producttypeid]);
		def item = [
			appid 			: data.appid,
			principal 		: data.totalprincipal,
			interest 		: data.interestamount,
			absentrate 		: producttype.absentpenalty,
			absentpenalty 	: data.absentpenalty,
			underpytrate 	: producttype.underpaymentpenalty,
			intrate 		: producttype.interestrate,
			schedule 		: data.dailydue,
			term 			: data.term,
			scheduledate 	: data.dtcurrentschedule
		]
		return new LoanApp(item);
	}

	public def buildBillingItemFact( params ) {
		def data = loan_ledger.read([objid: params.ledgerid]);
		
		Calendar c = Calendar.getInstance();
		c.setTime(params.txndate);
		def hassunday = false;
		if ((c.get(Calendar.DAY_OF_WEEK) - 1) == 1) hassunday = true;

		def avgamount = data.dailydue;
		if (data.paymentmethod == 'over') {
			def m = em.findAvgOverpaymentAmount([parentid: data.objid]);
			avgamount = (m? m.groupbaseamount : data.overpaymentamount);
			if (!avgamount) avgamount = data.dailydue;
		}//avgamount = em.findAvgOverpaymentAmount([parentid: data.objid]).groupbaseamount;
		
		def item = [
			ledgerid 		: data.objid,
			hassunday 		: hassunday,
			avgamount 		: avgamount,
			currentdate 	: params.txndate,
			dtschedule 		: data.dtcurrentschedule,
		]

		def days = dateSvc.getDaysDiff(item.dtschedule, item.currentdate);
		item.noofholidays = calendarSvc.getNoOfHolidays([lastscheduledate: item.dtschedule, item:[trialAndError: 0, totalDays: days]]);
		def prm = [startdate: item.dtschedule, enddate: item.currentdate, ledgerid: data.objid];
		def e = exemption.findTotaldaysExemptedByStartdateAndEnddateAndLedgeridWithoutHolidays(prm);
		item.noofdaysexempted =  (e.totaldays? e.totaldays : 0);

		return new LoanBillingItem(item);
	}

	private def buildAmnestyFact( params ) {
		def data = amnesty.findActiveAmnestyByLedgeridAndDate([ledgerid: params.ledgerid, date: parse("yyyy-MM-dd", params.txndate)]);
		def item = [:];
		if (data) {
			item.ledgerid = data.ledgerid;
			item.balance = data.balance;
			item.type = data.amnestyoption;
			item.waivedinterest = (data.iswaiveinterest > 0? true : false);
			item.waivedpenalty = (data.iswaivepenalty > 0? true : false);
		}
		return new Amnesty(item);
	}
/*
	@ProxyMethod
	public void createBilling( list, data, route ) {
		try {
			createBillingImpl(list, data, route);
		} catch(e) {
			e.printStackTrace();
			throw e;
		}
	}

	private void createBillingImpl( list, data, route ) {
		def days = 0;

		list.each{
			def currentDate = dateSvc.parseDate(data.billdate, null).date;
			def maturityDate = dateSvc.parseDate(it.dtmatured, null).date;
			if (currentDate >  maturityDate && it.overduepenalty == 0.00) {
				def p = product_type.read([name: it.producttypeid])
				it.overduepenalty = ledgerSvc.computeOverduePenalty([balance: it.balance, pastduerate: (p.pastduerate? p.pastduerate : 0.00)]);
				loan_ledger.update(it, 'overduepenalty');
			}
			def detail = [
				objid				: 'LLBD'+new UID(),
				parentid 			: data.objid,
				ledgerid 			: it.objid,
				route_code 			: route? route.code : it.route.code,
				acctid 				: it.acctid,
				loanappid 			: it.loanappid,
				acctname 			: it.acctname,
				loanamount 			: it.loanamount,
				loandate 			: it.loandate,
				term 				: it.term,
				appno 				: it.appno,
				overpaymentamount 	: it.overpaymentamount,
				txndate 			: currentDate,
				dailydue 			: it.dailydue,
				dtmatured 			: it.dtmatured,
				producttypeid 		: it.producttypeid,
				paymentmethod 		: it.paymentmethod,
				interestamount 		: it.interestamount,
				homeaddress 		: it.homeaddress,
				collectionaddress 	: it.collectionaddress? it.collectionaddress : '',
				interest 			: 0.00,
				others 				: 0.00,
				overduepenalty 		: it.overduepenalty
			];
			detail.refno = 'B'+seqSvc.getNextFormattedSeriesA('loanbill-'+detail.route_code, 8);
			
			def amt = it.dailydue;
			if (it.paymentmethod == 'over' && it.overpaymentamount > 0) amt = it.overpaymentamount; 
			days = dateSvc.getDaysDiff(it.dtcurrentschedule, currentDate);
			detail.amountdue = (amt*days)+detail.others;
			if (!it.compromiseid) {	
				def req = new RuleRequest("billing");
				def referencesFact = [					
					isFixed				: false,
					isOverdue			: (currentDate > maturityDate),
					hasSunday			: false,
					balance				: it.balance,
					absentPenalty		: it.absentpenalty,
					overduePenalty		: detail.overduepenalty,
					dailyDue			: amt,
					interest 			: detail.interestamount,
					overpayment			: it.overpaymentamount,
					others				: detail.others,
					totalDays			: days
				];
				req.addFact("billing", "References", referencesFact);
				req.addGlobal("detail", detail);
				referencesFact.noOfHolidays = calendarSvc.getNoOfHolidays([lastscheduledate: it.dtcurrentschedule, item:[trialAndError: 0, totalDays: days]]);
				referencesFact.noOfDaysExempted = exemption.getExemptionsByStartdateAndEnddateAndLedgerid([startdate: it.dtcurrentschedule, enddate: currentDate, ledgerid: it.objid]).size();
				
				def cal = Calendar.getInstance();
				cal.setTime(dateSvc.add(currentDate, "-"+referencesFact.noOfHolidays));
				if ((cal.get(cal.DAY_OF_WEEK)-1) == 1) {
					referencesFact.hasSunday = true;
				}

				ruleSvc.execute(req);
				if (detail.penalty) {
					detail.penalty = new BigDecimal(detail.penalty+'').setScale(2, BigDecimal.ROUND_HALF_UP);
				}

				if (detail.amountdue) {
					detail.amountdue = new BigDecimal(detail.amountdue+'').setScale(0, BigDecimal.ROUND_CEILING);
				}
				detail.balance = getBalance(detail, it.balance);
			} else {

			}
			em.create(detail, "detail");
		}
	}*/

	/*
	@ProxyMethod(local=true)
	public def getBalance( params, balance ) {
		def bal = balance? balance : 0.00;
		if (balance == params.loanamount) {
			def producttype = product_type.read([name: params.producttypeid]);
			bal = params.loanamount*(producttype.term/100);
			params.isfirstbill = 1;
		} else {
			def ledgeritem = loan_ledger.findLastLedgerItemByParentId([parentid: params.ledgerid]);
			if (params.overduepenalty > 0) {
				bal += params.days*params.interestamount;
			} else {
				def avgamount = params.dailydue;
				if (params.paymentmethod == 'over') avgamount = em.findAvgOverpaymentAmount([parentid: params.ledgerid]).groupbaseamount;
				BigDecimal b = new BigDecimal(avgamount+'').setScale(2);
				b = b.subtract(new BigDecimal(params.interestamount+'').setScale(2));
				BigDecimal bd = new BigDecimal(balance+'').setScale(2)
				bd = bd.divide(b, BigDecimal.ROUND_HALF_UP);
				bal += (bd.setScale(0, BigDecimal.ROUND_HALF_UP)*params.interestamount);
			}
			
			if (ledgeritem.interestbal > 0) {
				params.amountdue += ledgeritem.interestbal;
				bal += ledgeritem.interestbal;
				params.interest += ledgeritem.interestbal;
			}
			if (ledgeritem.penaltybal > 0) {
				params.amountdue += ledgeritem.penaltybal;
				bal += ledgeritem.penaltybal;
				params.penalty += ledgeritem.penaltybal;
			}
			params.isfirstbill = 0;
		}
		if (params.penalty > 0) bal += params.penalty;
		bal = new BigDecimal(bal+'').setScale(0, BigDecimal.ROUND_CEILING);
		bal = new BigDecimal(bal+'').setScale(2);
		return bal;
	}

	void updateRoute( data ) {
		em.removeRouteByBillingid([billingid: data.objid]);
		def params;
		data.routes.each{o->
			params = [
				billingid 	: data.objid,
				routecode 	: o.code,
				downloaded 	: 0,
				uploaded 	: 0
			];
			em.create(params, 'billing_route');
		}
	}*/

	public def open( params ) {
		def data = em.read(params);
		if (!data) throw new Exception('Billing record does not exist or has already been deleted.');
		//if (!data) throw new Exception("Record does not exist or has already been deleted.");

		//println 'state ' + params.state;
		//def routes = em.getRoutesByState([objid: data.objid, state: params.state]);
		data.routes = em.getRoutesByState([objid: data.objid, state: params.state]);
		//println 'routes';
		//data.routes.each{ println it }
		//data.routes = routes?.findAll{ it?.code == params?.route?.code }

		data.resetable = false;
		data.forsubbilling = false;
		data.allowfollowupcollection = false;
		data.allowspecialcollection = false;

		def currentdate = dateSvc.getServerDateAsString().split(" ")[0];
		//def billdate = (data.billdate instanceof Date? data.billdate.toString() : data.billdate);
		def billdate = String.valueOf(data?.billdate);

		def regex = 'CANCELLED|CLOSED';
		if (currentdate.compareTo(billdate) <= 0 && (!params.state || !params.state.matches(regex))) {
			data.forsubbilling = true;
			data.resetable = true;
			data.allowfollowupcollection = true;
			data.allowspecialcollection = true;
		}

		data.editable = false;
		data.state = params.state;
		if (data.state == 'FOR_DOWNLOAD') {
			data.editable = (em.findDownloadedRoute(data)? false : true);
		}

		def s = billing_assist.findByPrevbillingidAndPrevitemid([objid: data?.objid, itemid: params.itemid]);
		if (s) data.subbillingid = s.objid;

		regex = 'FOR_DOWNLOAD|DOWNLOADED';
		if (data.state?.matches(regex)) {
			data.allowcancel = true;
		}

		regex = 'PENDING_CANCEL_REQUEST|FOR_APPROVAL_CANCEL_REQUEST';
		if (data.state?.matches(regex)) {
			data.resetable = false;
		}

		for (def i=0; i<data.routes.size(); i++) {
			def xi = em.read([objid: data.routes[i].itemid], "billing-item");
			if (xi) {
				data.allowexport = true;
				break;
			}
		}
		//def i = em.read([objid: params.itemid], "billing-item");
		//if (i) data.allowexport = true;

		return data;
	}

	@Async
	@ProxyMethod(local=true)
	public def resetBilling( params ) {
		def billing = em.read(params);
		if (!billing) throw new Exception("Billing record does not exist or has already been deleted.");

		def modifiedby =  [objid: env.USERID, name: env.NAME];
		def item, list, fcitem;
		params.routes.each{ o->
			item = em.findByBillingidAndItemid([objid: params.objid, itemid: o.code]);
			if (!item) throw new Exception("Billing record does not exist or has already been deleted.");

			item.dtmodified = dateSvc.serverDate;
			item.modifiedby = modifiedby;
			em.update(item, "billing-item");
			item.billdate = params.billdate;

			fcitem = fieldcollection.read(item, "fc-item");
			if (!fcitem) {
				em.removeBillingDetail(item);

				o.billdate = params.billdate;
				o.billingid = billing.objid;
				createBillingByRoute(o);

				//process.create(item);

				//list = loan_ledger.getCollectionsheets([route_code: o.code]);
				//list.each{ l->
				//	process.create([ objid: l.objid, parentid: item.objid ], "detail");
				//}
				//createBillingByRoute(list, item, o);
			} 
			//else {
			if (item.state != 'FOR_DOWNLOAD') {
				if (item.state == 'DOWNLOADED') billing.totaldownloaded--;
				//billing.totalfordownload++;
				item.state = 'FOR_DOWNLOAD';
			}
			em.changeState(item);
			//}
		}
		em.update(billing, "fordownload");
		em.update(billing, "downloaded");
	}

	@ProxyMethod
	public def cancelBilling( params ) {
		def billing = em.read([objid: params.objid]);
		if (!billing) throw new RuntimeException('Billing record does not exist or has already been deleted.');

		def r;
		if (params.routes) {
			r = params.routes[0];
		}

		def item = em.read([objid: r?.itemid], 'billing-item');
		if (!item) throw new RuntimeException('Billing record does not exist or has already been deleted.');

		def serverdate = dateSvc.serverDate;

		def req = ledger_billing_cancelrequest.findBillingCancelRequestByState([itemid: item.objid, state: 'PENDING']);
		if (!req) {
			req = [
				objid		: 'BCR' + new UID(),
				dtfiled		: serverdate,
				author		: [objid: env.USERID, name: env.NAME],
				billing 	: [itemid: item.objid, state: item.state, date: billing.billdate, description: r?.description],
				collector 	: billing.collector,
				txnstate	: 'PENDING',
				remarks 	: params.cancelremarks
			];

			ledger_billing_cancelrequest.create(req);
		}


		//println 'state ' + data.state + ' ' + (!data.state.matches("FOR_DOWNLOAD|DOWNLOADED"));

		if (!item.state.matches("FOR_DOWNLOAD|DOWNLOADED")) {
			throw new RuntimeException("Cannot cancel billing. The billing has already been ${data.state}.");
		}

		def state = "PENDING_CANCEL_REQUEST";
		if (item.state == "FOR_DOWNLOAD") {
			req.txnstate = "FOR_APPROVAL";
			ledger_billing_cancelrequest.update(req);

			state = "FOR_APPROVAL_CANCEL_REQUEST";
			//data = changeStateImpl(data, "FOR_APPROVAL_CANCEL_REQUEST");

			//def filetype = (followupcollection.read(data)? 'followupcollection' : 'specialcollection');
			/*
			def prm = [
				objid		: req.objid,
				recipient 	: 'APPROVER',
				filetype 	: "billing:cancel:request",
				message 	: 'Submitted for approval cancel billing request.'
			];
			addInbox(prm);
			*/
			def msginfo = [ 
				objid 		: req.objid, 
				dtcreated	: serverdate, 
				refid 		: req.objid, 
				filetype 	: "billing:cancel:request", 
				message 	: 'Submitted for approval cancel billing request.', 
				senderid	: env.USERID, 
				sendername 	: env.NAME, 
				recipientid : 'APPROVER'
			]; 
			inboxSvc.addMessage( msginfo );
		}
		item.state = state;
		em.changeState(item);

		r.state = state;
		params.state = state;
		params.route = r; 
		def data = open(params);
		return data;
		/*
		item.state = 'CANCELLED';
		item.dtcancelled = dateSvc.serverDate;
		item.cancelledby = [objid: env.USERID, name: env.NAME];
		em.update(item, 'cancel-item');
		em.update([objid: item.objid, state: item.state], 'billing-item');

		r.state = item.state;
		params.state = r.state;
		params.route = r;

		def data = open(params);
		return data;
		*/
	}

	@ProxyMethod
	public def getReportData( params ) {
		def sv = var.read([name: "report_export_path"]);
		def path = sv?.value;
		if (!path) path = "";

		def data = em.read([objid: params.itemid], "billing-item");
		def b = em.read([objid: data.parentid]);
		def route = loan_route.read([code: data.item.objid]);


		def filename = b.billdate.toString() + "_" + b.collector.name + "_" + data.objid.replaceAll(":", "_") + "_" + route?.description + ".pdf";

		def branch = branchSvc.open([:]);
		def rptparams = [:];
		branch.each{ k, v->
			rptparams["branch_" + k] = v;
		}

		def list = [];
		def items = em.getBillingDetailsWithNextto([objid: data.objid]);
		items.each{ o->
			def map = [
				refno 		: o.refno,
				acctname	: o.acctname,
				dtreleased	: o.dtreleased,
				dtmatured 	: o.dtmatured,
				route 		: route
			];

			def itm, itm2;
			def l = loan_ledger.read([objid: o.ledgerid]);
			def joints = loanapp_borrower.getJointBorrowers([parentid: l?.appid]); 
			joints.each{ j->
				itm = customer.read([objid: j.objid]);
				if (itm) {
					if (itm.type == 'INDIVIDUAL') {
						itm2 = customerindividual.read([objid: itm.objid]);
						map.acctname += " AND " + itm2.lastname + ', ' + itm2.firstname;
					}
				}
			}
			def ac = ledgeramnesty.findActiveByDateAndLedgerid([date: data.txndate, ledgerid: o.ledgerid]);
			if (ac) {
				def str = "\n(" + ac.type + ": ";
				switch (ac.type) {
					case 'FIX': 
						def af = ledgeramnesty_fix.read([objid: ac.refid]);
						//println 'amount ' + af.amount + ' dtstarted ' + af.dtstarted + ' dtended ' + af.dtended;
						str += DEC_FORMAT.format(af.amount) + " SD: " + DATE_FORMAT1.format(parseDate(af.dtstarted));
						if (af.dtended) {
							str += " ED: " + DATE_FORMAT1.format(parseDate(af.dtended));
						}
						break;
					default :
						str += ac.description + " SD: " + DATE_FORMAT1.format(parseDate(ac.dtstarted));
						break;
				}
				str += ")";
				map.acctname += str;
			}

			list << map;
		}

		list.sort{ it.refno }

		def rowsize = 20;
		def s = list.size() / rowsize;
		s =  list.size() - (s.toInteger() * rowsize);
		s = rowsize - s.toInteger();

		s += rowsize;
		for (def i=0; i<s; i++) {
			list << [route: route];
		}

		def idx = 0;
		for (def i=0; i<list.size(); i++) {
			if (i >= ((idx + 1) * rowsize)) {
				idx++;
			}
			list[i].page = idx;
		}

		return [path: path, filename: filename, rptdata: list, rptparams: rptparams];
	}
}
